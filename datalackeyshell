#!/usr/bin/ruby

require 'optparse'
require 'readline'
require 'shellwords'
require 'open3'
require 'json'

$version = 1

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
  end

  def parse(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyshell [options]"
      opts.separator ""
      opts.separator "Options:"
      opts.on("-m", "--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("-d", "--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit
      end
      opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("-p", "--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
    end
    parser.parse!(args)
    # Perform sanity checks on the values.
    if @memory and not (@directory.nil? and @permissions.nil?)
      puts "Cannot use both --memory and --directory or --permissions."
      exit
    end
    if not @memory
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      @permissions = "600" if @permissions == nil
    end
  end
end

arguments = Arguments.new
arguments.parse(ARGV)

exe = arguments.lackey
if exe == nil
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  for k in 0 ... dirs.length
    exe = File.join(dirs[k], "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  puts("datalackey not found.") if exe == nil
else
  if not File.exist?(exe) or not File.executable?(exe)
    puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe == nil

class LackeyProcess
  attr_reader :exit_code, :stdout, :stderr
  attr_accessor :echo

  def initialize(exe, directory, permissions, memory)
    @echo = false
    @accum_stdout = []
    @ready_stdout = Queue.new
    @unwanted_stderr = Queue.new
    args = [ exe,
        '--command-in', 'stdin', 'JSON', '--command-out', 'stdout', 'JSON' ]
    args.push('--memory') if memory
    args.concat([ '--directory', directory ]) if directory != nil
    args.concat([ '--permissions', permissions ]) if not memory
    @stdin, @stdout, @stderr, @wait_thread = Open3.popen3(*args)
    @read_stdout = Thread.new do
      while true do
        begin
          raw = @stdout.readpartial(32768)
        rescue EOFError
          break
        end
        loc = raw.index("\n")
        until loc.nil? do
          @accum_stdout.push(raw[0, loc]) if loc > 0 # Newline begins?
          # Found full line that is not empty.
          @ready_stdout.push(@accum_stdout.join) if @accum_stdout.length
          @accum_stdout.clear
          raw = raw[loc + 1, raw.length - loc - 1]
          loc = raw.index("\n")
        end
        @accum_stdout.push(raw) if raw.length > 0
      end
      @stdout.close
    end
    @read_stderr = Thread.new do
      while true do
        begin
          raw = @stderr.readpartial(32768)
        rescue EOFError
          break
        end
        # There should be nothing so no sweat on processing.
        @unwanted_stderr.push(raw)
      end
      @stderr.close
    end
  end

  def relay(message)
    @stdin.write message
    puts(message) if @echo
  end

  def finish
    @stdin.close
    @wait_thread.join
    @exit_code = @wait_thread.value.exitstatus
  end

  def wait_output
    @read_stdout.join
    @read_stderr.join
  end

  def get_output
    return nil if @ready_stdout.empty?
    return @ready_stdout.pop
  end

  def get_lackey_error
    return nil if @unwanted_stderr.empty?
    return @unwanted_stderr.pop
  end
end

$lackey = LackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)

$prompt = '> '
def reprompt
  print $prompt
  STDOUT.flush
  Readline.redisplay
end

def prompt_print(message)
  puts
  puts message
  reprompt
end

class OutputPresenter
  def initialize
    @handlers = Hash.new(nil)
    @present_output = Thread.new do
      last_stderr = false
      had_output = false
      until $lackey.stdout.closed? and $lackey.stderr.closed?
        had_output = false
        while out = $lackey.get_output
          break if out.nil?
          arr = JSON.parse(out)
          handler = @handlers[arr[1]]
          break if handler.nil?
          handler.present(arr, out)
          last_stderr = false
          had_output = true
        end
        while out = $lackey.get_lackey_error
          break if out.nil?
          head = last_stderr ? '' : 'STDERR:'
          prompt_print head + out
          last_stderr = true
          had_output = true
        end
        sleep(0.1) unless had_output
      end
    end
  end

  def handle(command, handler)
    @handlers[command] = handler
  end

  def wait_output
    @present_output.join
  end
end
$presenter = OutputPresenter.new

class IdentifierGenerator
  def initialize
    @last = 0
  end

  def get
    @last += 1
    return @last
  end
end
$identifier = IdentifierGenerator.new

$handler = Hash.new(nil)
$exiting = false

class Handler
  def initialize(usage_text, help_text, extended_help_text=nil)
    @usage_text = usage_text
    @help_text = help_text
    @extended_help_text = extended_help_text
  end

  def help
    puts "#{@usage_text} : #{@help_text}"
    puts(@extended_help_text) unless @extended_help_text.nil?
  end

  def usage
    puts "Usage: #{@usage_text}"
  end

  def incoming(identifier)
    $presenter.handle(identifier, self)
  end

  def relay(message)
    $lackey.relay(message)
  end

  def present_error(parsed, json)
    prompt_print "ERROR: " + parsed[3...parsed.length].join(" ")
  end

  def present_invalid(parsed, json)
    prompt_print "INVALID: " + parsed[3...parsed.length].join("\n")
  end

  def present_missing(parsed, json)
    prompt_print "MISSING: " + parsed[3...parsed.length].join("\n")
  end

  def present_other(parsed, json)
    start = parsed[2] == '' ? 3 : 2
    prompt_print(parsed[start...parsed.length].join("\n")) if parsed.length > 3
  end

  def present(parsed, json)
    return if parsed.length < 3
    if parsed[2] == 'error'
      present_error(parsed, json)
    elsif parsed[2] == 'invalid'
      present_invalid(parsed, json)
    elsif parsed[2] == 'missing'
      present_missing(parsed, json)
    else
      present_other(parsed, json)
    end
  end
end

class HelpHandler < Handler
  def initialize
    super('help', "Print command help.")
  end

  def handle(parts)
    $handler.keys.sort.each do |key|
      $handler[key].help
    end
  end
end
$handler['help'] = HelpHandler.new

class ExitHandler < Handler
  attr_reader :code

  def initialize
    super("exit [code]", "Waits for datalackey to finish, exits with code.")
    @code = 0
  end

  def handle(parts)
    return usage() if parts.length > 2
    $exiting = true
    return if parts.length == 1
    begin
      @code = Integer(parts[1])
    rescue ArgumentError
      usage
      $exiting = false
    end
  end
end
$handler['exit'] = ExitHandler.new

class ListHandler < Handler
  def initialize
    super("list", "Prints out the list of labels.")
    incoming 'list'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"list\"]"
  end
end
$handler['list'] = ListHandler.new

class SetHandler < Handler
  def initialize
    super("set label value", "Sets label to JSON-encoded value", "  Enclose value in single quotes as needed, escaping any single quotes within.")
  end

  def handle(parts)
    return usage() if parts.length < 3
    v = parts[2...parts.length].join("")
    relay "{\"#{parts[1]}\":#{v}}"
  end
end
$handler['set'] = SetHandler.new

class GetHandler < Handler
  def initialize
    super("get label...", "Gets labels.")
    incoming 'get'
  end

  def handle(parts)
    return usage() if parts.length < 2
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"get\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != ''
    head = "[#{parsed[0]},\"#{parsed[1]}\",\"\","
    prompt_print json[head.length...json.length - 1]
  end
end
$handler['get'] = GetHandler.new

class RenameHandler < Handler
  def initialize
    super("mv label new-label ...", "Re-labels values. Takes label pairs.")
    incoming 'rename'
  end

  def handle(parts)
    return usage() if (parts.length - 1) % 2 != 0
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"rename\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != 'renamed' and parsed.length != 5
    prompt_print "#{parsed[3]} -> #{parsed[4]}"
  end
end
$handler['mv'] = RenameHandler.new

class DeleteHandler < Handler
  def initialize
    super("rm label ...", "Removes labels from storage.")
  end

  def handle(parts)
    return usage() if parts.length == 1
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"delete\",\"#{names}\"]"
  end
end
$handler['rm'] = DeleteHandler.new

class StorageInfoHandler < Handler
  def initialize
    super("info", "Print information about storage.")
    incoming 'storage-info'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"storage-info\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length != 4
    puts
    parsed[3].keys.sort.each do |label|
      info = parsed[3][label]
      description = "#{label} : "
      sep = ''
      info.keys.sort.each do |format|
        description.concat "#{sep}#{format}: #{info[format]}"
        sep = ', '
      end
      puts description
    end
    reprompt
  end
end
$handler['info'] = StorageInfoHandler.new

class PingHandler < Handler
  def initialize
    super("ping", "Check that datalackey responds.")
    incoming 'no-op'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"no-op\"]"
  end

  def present_other(parsed, json)
    prompt_print "Datalackey responded."
  end
end
$handler['ping'] = PingHandler.new

class VersionHandler < Handler
  def initialize
    super("version", "Print version information.")
    incoming 'version'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"version\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length != 4
    description = "shell: #{$version}"
    parsed[3].keys.sort.each do |key|
      description.concat "\n#{key}: #{parsed[3][key]}"
    end
    prompt_print description
  end
end
$handler['version'] = VersionHandler.new

class EchoHandler < Handler
  def initialize
    super("echo on|off", "Set printing of commands sent to datalackey on or off.")
  end

  def handle(parts)
    return usage() if parts.length != 2 or not ['on', 'off'].include? parts[1]
    $lackey.echo = parts[1] == 'on'
  end
end
$handler['echo'] = EchoHandler.new

class HistoryHandler < Handler
  def initialize
    super("history [regex ...]", "Print commands that match any regex, or all.")
  end

  def handle(parts)
    exps = Array.new
    parts[1...parts.length].each do |e|
      exps.push Regexp.new(e)
    end
    Readline::HISTORY.take(Readline::HISTORY.length - 1).each do |h|
      match = exps.length == 0
      exps.each do |e|
        match = e.match(h)
        break if match
      end
      puts(h) if match
    end
  end
end
$handler['history'] = HistoryHandler.new


while line = Readline.readline($prompt, true)
  parts = line.shellsplit
  next if parts.length == 0
  h = $handler[parts[0]]
  if h.nil?
    puts "Unknown command: #{parts[0]}"
  else
    h.handle(parts)
  end
  break if $exiting

  # datalackey direct commands:
  # Run (run) See below for all parts.
  # Processes (ps)
  # Terminate (kill identifier)
  # Feed (feed identifier [name=]label|direct name=value ...)
  # EndFeed (eof identifier)

  # Run helper commands.
  # input name=label|direct name=value ... Construct/clear input mapping.
  # input+ name=label|direct name=value ... Append to input mapping.
  # output label=name ... Construct/clear output mapping.
  # output+ label=name ... Append to output mapping.
  # format in|out json When there is an alternative.
  # channel in|out pipe|shared_memory When there is an alternative.
  # env var=value ... Contruct/clear environment.
  # env+ var=value ... Append to environment.
  # args arguments as they are... Construct/clear program argument list.
  # args+ arguments as they are... Append to program argument list.
  # run program [eof] Run using input, output, format, channel, env, args.
  #  Optional eof indicates to close feed in the same call.
  # print input, output, format, channel, env, args Print argument state or
  #  without arguments print them all.
  # recall program input output format channel env args Fetches value from
  #  last run of program, without argumets fetches all.
  # re-run program ... Like "recall program ..." and "run program" so uses
  #  current for parts that have not been recalled.
  #  recall allows for editing values, re-run direct re-use
end

$lackey.finish
$lackey.wait_output
$presenter.wait_output
puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit $handler['exit'].code
