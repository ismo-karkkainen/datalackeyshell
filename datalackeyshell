#!/usr/bin/env ruby

# Argument handling and checking
# datalackey process
# Presenting command output
# Notification presenters
# Command handlers
# Run command handlers

require 'optparse'
require 'readline'
require 'shellwords'
require 'open3'
require 'json'
require 'set'
require 'pathname'

$version = 1
history_file_basename = '.datalackeyshell.history'
history_file_max_lines = 2000

# Argument handling and checking

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
  end

  def parse(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyshell [options]"
      opts.separator ""
      opts.separator "Options:"
      opts.on("-m", "--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("-d", "--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit
      end
      opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("-p", "--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
    end
    parser.parse!(args)
    # Perform sanity checks on the values.
    if @memory and not (@directory.nil? and @permissions.nil?)
      puts "Cannot use both --memory and --directory or --permissions."
      exit
    end
    if not @memory
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      @permissions = "600" if @permissions == nil
    end
  end
end

arguments = Arguments.new
arguments.parse(ARGV)

exe = arguments.lackey
if exe == nil
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  for k in 0 ... dirs.length
    exe = File.join(dirs[k], "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  puts("datalackey not found.") if exe == nil
else
  if not File.exist?(exe) or not File.executable?(exe)
    puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe == nil

# datalackey process

class LackeyProcess
  attr_reader :exit_code, :stdout, :stderr
  attr_accessor :echo

  def initialize(exe, directory, permissions, memory)
    @echo = false
    @accum_stdout = []
    @ready_stdout = Queue.new
    @unwanted_stderr = Queue.new
    args = [ exe,
        '--command-in', 'stdin', 'JSON', '--command-out', 'stdout', 'JSON' ]
    args.push('--memory') if memory
    args.concat([ '--directory', directory ]) if directory != nil
    args.concat([ '--permissions', permissions ]) if not memory
    @stdin, @stdout, @stderr, @wait_thread = Open3.popen3(*args)
    @read_stdout = Thread.new do
      while true do
        begin
          raw = @stdout.readpartial(32768)
        rescue EOFError
          break
        end
        loc = raw.index("\n")
        until loc.nil? do
          @accum_stdout.push(raw[0, loc]) if loc > 0 # Newline begins?
          # Found full line that is not empty.
          @ready_stdout.push(@accum_stdout.join) if @accum_stdout.length
          @accum_stdout.clear
          raw = raw[loc + 1, raw.length - loc - 1]
          loc = raw.index("\n")
        end
        @accum_stdout.push(raw) if raw.length > 0
      end
      @stdout.close
    end
    @read_stderr = Thread.new do
      while true do
        begin
          raw = @stderr.readpartial(32768)
        rescue EOFError
          break
        end
        # There should be nothing so no sweat on processing.
        @unwanted_stderr.push(raw)
      end
      @stderr.close
    end
  end

  def relay(message)
    @stdin.write message
    puts(message) if @echo
  end

  def reset
    @stdin.putc 0
  end

  def finish
    @stdin.close
    @wait_thread.join
    @exit_code = @wait_thread.value.exitstatus
  end

  def wait_output
    @read_stdout.join
    @read_stderr.join
  end

  def get_output
    return nil if @ready_stdout.empty?
    return @ready_stdout.pop
  end

  def get_lackey_error
    return nil if @unwanted_stderr.empty?
    return @unwanted_stderr.pop
  end
end

$lackey = LackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)

# Presenting command output

$prompt = '> '
def reprompt
  print $prompt
  STDOUT.flush
  Readline.redisplay
end

def prompt_print(message)
  puts
  puts message
  reprompt
end

class OutputPresenter
  attr_accessor :echo

  def initialize
    @handlers = Hash.new(nil)
    @present_output = Thread.new do
      last_stderr = false
      had_output = false
      until $lackey.stdout.closed? and $lackey.stderr.closed?
        had_output = false
        while out = $lackey.get_output
          break if out.nil?
          puts(out) if @echo
          arr = JSON.parse(out)
          handler = @handlers[arr[1]]
          break if handler.nil?
          handler.present(arr, out)
          last_stderr = false
          had_output = true
        end
        while out = $lackey.get_lackey_error
          break if out.nil?
          head = last_stderr ? '' : 'STDERR:'
          prompt_print head + out
          last_stderr = true
          had_output = true
        end
        sleep(0.1) unless had_output
      end
    end
  end

  def handle(command, handler)
    @handlers[command] = handler
  end

  def wait_output
    @present_output.join
  end
end
$presenter = OutputPresenter.new

class IdentifierGenerator
  def initialize
    @last = 0
  end

  def get
    @last += 1
    return @last
  end
end
$identifier = IdentifierGenerator.new

# Notification presenters

class PresentError
  def initialize
    $presenter.handle('error', self)
  end

  def present(parsed, json)
    prompt_print "Datalackey input format error, resetting stream."
    $lackey.reset
  end
end
$error_presenter = PresentError.new

# Command handlers

$handler = Hash.new(nil)
$exiting = false

class Handler
  attr_reader :help, :usage, :extended_help

  def print_help(short)
    puts "#{@usage} : #{@help}"
    puts(@extended_help) unless @extended_help.nil? or short == true
  end

  def print_usage
    puts "Usage: #{@usage}"
  end

  def incoming(identifier)
    $presenter.handle(identifier, self)
  end

  def relay(message)
    $lackey.relay(message)
  end

  def present_error(parsed, json)
    prompt_print "ERROR: " + parsed[3...parsed.length].join(" ")
  end

  def present_invalid(parsed, json)
    prompt_print "INVALID: " + parsed[3...parsed.length].join("\n")
  end

  def present_missing(parsed, json)
    prompt_print "MISSING: " + parsed[3...parsed.length].join("\n")
  end

  def present_other(parsed, json)
    start = parsed[2] == '' ? 3 : 2
    prompt_print(parsed[start...parsed.length].join("\n")) if parsed.length > 3
  end

  def present(parsed, json)
    return if parsed.length < 3
    if parsed[2] == 'error'
      present_error(parsed, json)
    elsif parsed[2] == 'invalid'
      present_invalid(parsed, json)
    elsif parsed[2] == 'missing'
      present_missing(parsed, json)
    else
      present_other(parsed, json)
    end
  end
end

class HelpHandler < Handler
  def initialize
    @usage = 'help|usage [command ...]'
    @help = "Print command help or short usage."
  end

  def handle(parts)
    short = parts[0] == 'usage'
    printed = Set.new
    keys = (parts.length > 1) ? parts[1...parts.length] : $handler.keys
    keys.sort.each do |key|
      if $handler.include? key
        object = $handler[key]
        next if printed.include? object
        printed.add object
        object.print_help(short)
      else
        puts "Unknown command: #{key}"
      end
    end
  end
end
$handler['help'] = HelpHandler.new
$handler['usage'] = $handler['help']

class ExitHandler < Handler
  attr_reader :code

  def initialize
    @usage = 'exit [code]'
    @help = "Waits for datalackey to finish, exits with code."
    @code = 0
  end

  def handle(parts)
    return print_usage() if parts.length > 2
    $exiting = true
    return if parts.length == 1
    begin
      @code = Integer(parts[1])
    rescue ArgumentError
      print_usage
      $exiting = false
    end
  end
end
$handler['exit'] = ExitHandler.new

class ListHandler < Handler
  def initialize
    @usage = 'list'
    @help = "Prints out the list of labels."
    incoming 'list'
  end

  def handle(parts)
    return print_usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"list\"]"
  end
end
$handler['list'] = ListHandler.new

class SetHandler < Handler
  def initialize
    @usage = 'set label value'
    @help = "Sets label to JSON-encoded value"
    @extended_help = "  Enclose value in single quotes as needed, escaping any single quotes within."
  end

  def handle(parts)
    return print_usage() if parts.length < 3
    v = parts[2...parts.length].join("")
    relay "{\"#{parts[1]}\":#{v}}"
  end
end
$handler['set'] = SetHandler.new

class GetHandler < Handler
  def initialize
    @usage = 'get label ...'
    @help = "Gets labels."
    incoming 'get'
  end

  def handle(parts)
    return print_usage() if parts.length < 2
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"get\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != ''
    head = "[#{parsed[0]},\"#{parsed[1]}\",\"\","
    prompt_print json[head.length...json.length - 1]
  end
end
$handler['get'] = GetHandler.new

class RenameHandler < Handler
  def initialize
    @usage = "rename label new-label ..."
    @help = "Re-labels values. Takes label pairs."
    incoming 'rename'
  end

  def handle(parts)
    return print_usage() if (parts.length - 1) % 2 != 0
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"rename\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != 'renamed' and parsed.length != 5
    prompt_print "#{parsed[3]} -> #{parsed[4]}"
  end
end
$handler['rename'] = RenameHandler.new

class DeleteHandler < Handler
  def initialize
    @usage = "remove label ..."
    @help = "Removes labels from storage."
  end

  def handle(parts)
    return print_usage() if parts.length == 1
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"delete\",\"#{names}\"]"
  end
end
$handler['remove'] = DeleteHandler.new

class StorageInfoHandler < Handler
  def initialize
    @usage = "info"
    @help = "Print information about storage."
    incoming 'storage-info'
  end

  def handle(parts)
    return print_usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"storage-info\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length != 4
    puts
    parsed[3].keys.sort.each do |label|
      info = parsed[3][label]
      description = "#{label} : "
      sep = ''
      info.keys.sort.each do |format|
        description.concat "#{sep}#{format}: #{info[format]}"
        sep = ', '
      end
      puts description
    end
    reprompt
  end
end
$handler['info'] = StorageInfoHandler.new

class PingHandler < Handler
  def initialize
    @usage = "ping"
    @help = "Check that datalackey responds."
    incoming 'no-op'
  end

  def handle(parts)
    return print_usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"no-op\"]"
  end

  def present_other(parsed, json)
    prompt_print "Datalackey responded."
  end
end
$handler['ping'] = PingHandler.new

class VersionHandler < Handler
  def initialize
    @usage = "version"
    @help = "Print version information."
    incoming 'version'
  end

  def handle(parts)
    return print_usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"version\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length != 4
    description = "shell: #{$version}"
    parsed[3].keys.sort.each do |key|
      description.concat "\n#{key}: #{parsed[3][key]}"
    end
    prompt_print description
  end
end
$handler['version'] = VersionHandler.new

class EchoHandler < Handler
  def initialize
    @usage = "lackey in|out on|off"
    @help = "Set the printing of datalackey input or output on or off."
  end

  def handle(parts)
    return print_usage() unless parts.length == 3
    return print_usage() unless ['in', 'out'].include? parts[1]
    return print_usage() unless ['on', 'off'].include? parts[2]
    $lackey.echo = parts[2] == 'on' if parts[1] == 'in'
    $presenter.echo = parts[2] == 'on' if parts[1] == 'out'
  end
end
$handler['lackey'] = EchoHandler.new

class NotifyHandler < Handler
  def initialize
    @usage = "notify process|data on|off"
    @help = "Turn process or data notifications on or off."
    incoming 'process'
    incoming 'data'
    @notify = { 'process' => 'off', 'data' => 'on' }
  end

  def handle(parts)
    if parts.length != 1
      return print_usage() unless parts.length == 3
      return print_usage() unless @notify.include? parts[1]
      return print_usage() unless ['on', 'off'].include? parts[2]
      @notify[parts[1]] = parts[2]
    end
    @notify.keys.sort.each do |key|
      puts "#{key} : #{@notify[key]}"
    end
  end

  def present(parsed, json)
    prompt_print "#{parsed[1].capitalize} #{parsed[2]} : #{parsed[3]}"
  end
end
$handler['notify'] = NotifyHandler.new

def scan_history(regexps)
  matched = Array.new
  Readline::HISTORY.take(Readline::HISTORY.length - 1).each do |h|
    match = regexps.length == 0
    regexps.each do |e|
      match = e.match(h)
      break if match
    end
    matched.push(h) if match
  end
  return matched
end

class HistoryHandler < Handler
  def initialize
    @usage = "history [regex ...]"
    @help = "Print commands that match any regex, or all."
  end

  def handle(parts)
    exps = Array.new
    parts[1...parts.length].each do |e|
      exps.push Regexp.new(e)
    end
    scan_history(exps).each do |h|
      puts h
    end
  end
end
$handler['history'] = HistoryHandler.new

class RecallHandler < Handler
  def initialize
    @usage = "recall [identifier]"
    @help = "Fetch last \"run identifier\" related settings from history."
    @extended_help = "  Finds from history the input, output, env, arg, and channel settings\n"\
      "  that were in effect when last run with given identifier was done.\n"\
      "  If no identifier is given, last run command identifier is used.\n"\
      "  Prints the lines found from history."
  end

  def scan_until_first(new_to_old, exps)
    regexps = Array.new
    exps.each do |e|
      regexps.push Regexp.new(e)
    end
    matches = Array.new
    new_to_old.each do |c|
      for k in 0...regexps.length
        next unless regexps[k].match(c)
        matches.push(c)
        return matches if k == 0
        break
      end
    end
    return matches
  end

  def print_until_first(new_to_old, exps)
    n2o = scan_until_first(new_to_old, exps)
    while not n2o.empty?
      puts n2o.pop
    end
  end

  def handle(parts)
    return print_usage() if parts.length > 2
    id_given = parts.length == 2
    es = [ '^input[+]?[[:blank:]]+', '^output[+]?[[:blank:]]+',
      '^arg[+]?[[:blank:]]+', '^env[+]?[[:blank:]]+', '^env-clear$',
      '^channel[[:blank:]]+', '^exit' ]
    es.push('^run[[:blank:]]+' + (id_given ? parts[1] + '[[:blank:]]+' : ''))
    exps = Array.new
    es.each do |e|
      exps.push Regexp.new(e)
    end
    candidates = scan_history(exps)
    # Drop everything after the last matching run command.
    while not candidates.empty? and not candidates.last.start_with? 'run'
      candidates.pop
    end
    # Pick commands before last exit. Reverses order.
    session = Array.new
    while not candidates.empty? and not candidates.last.start_with? 'exit'
      session.push candidates.pop
    end
    print_until_first(session, [ '^channel[[:blank:]]+in[[:blank:]]' ])
    print_until_first(session, [ '^channel[[:blank:]]+out[[:blank:]]' ])
    print_until_first(session, [ '^channel[[:blank:]]+err[[:blank:]]' ])
    print_until_first(session, [ '^env[[:blank:]]', '^env[+][[:blank:]]', '^env-clear$' ])
    print_until_first(session, [ '^arg[[:blank:]]', '^arg[+][[:blank:]]' ])
    print_until_first(session, [ '^input[[:blank:]]', '^input[+][[:blank:]]' ])
    print_until_first(session, [ '^output[[:blank:]]', '^output[+][[:blank:]]', '^output-naming[[:blank:]]' ])
  end
end
$handler['recall'] = RecallHandler.new

# Run command handlers

class InputHandler < Handler
  def initialize
    @usage = "input[+] [name : label | name = value ...]\ninput?"
    @help = "Map input name to label/value or print mapping."
    @extended_help = "  Passes label as name, or value of name as given directly.\n"\
      "  Allowed values are integers and strings. Quote '\"string value\"'.\n"\
      "  input+ appends to current mapping, input clears it first.\n"\
      "  input? prints current mapping."
    @order = Array.new
    @mapping = Hash.new
  end

  def handle(parts)
    if parts[0] == 'input?'
      return print_usage() if parts.length != 1
      @order.each do |name|
        direct, val = @mapping[name]
        t = direct ? "=" : ":"
        puts "#{name} #{t} #{val}"
      end
      return
    end
    return print_usage() if (parts.length % 3) != 1
    clear = parts[0] == 'input'
    order_in = Array.new
    map_in = Hash.new
    idx = 1
    while idx < parts.length
      name = parts[idx]
      return print_usage() unless [':', '='].include? parts[idx + 1]
      direct = parts[idx + 1] == '='
      src = parts[idx + 2]
      idx += 3
      if map_in.has_key?(name) or not clear and @mapping.has_key?(name)
        puts "Error: #{name} already in mapping."
        return
      end
      if direct
        begin
          check = JSON.load(src)
        rescue JSON::ParserError
          puts "Error: #{name} value is invalid: #{src}"
          return
        end
      end
      order_in.push name
      map_in[name] = [direct, src]
    end
    if clear
      @order.clear
      @mapping.clear
    end
    @order.concat order_in
    @mapping.merge! map_in
  end

  def command_part
    command = ''
    @order.each do |name|
      direct, val = @mapping[name]
      if direct
        command.concat ",\"direct\",#{val},\"#{name}\""
      else
        command.concat ",\"input\",\"#{val}\",\"#{name}\""
      end
    end
    return command
  end
end
$handler['input'] = InputHandler.new
$handler['input+'] = $handler['input']
$handler['input?'] = $handler['input']

class OutputHandler < Handler
  def initialize
    @usage = "output[+] [label name ...]\n"\
      "output-naming prefix postfix\noutput?"
    @help = "Map output name to label or print out current mapping."
    @extended_help = "  Maps name to label. Using null as label discards that name.\n"\
      "  output+ adds to current mapping, output clears it first.\n"\
      "  output-naming sets prefix and postfix to names that have no match.\n"\
      "  output? prints out current mapping."
    @mapping = Hash.new
    @prefix = nil
    @postfix = nil
  end

  def handle(parts)
    return print_usage() if (parts.length % 2) != 1
    if parts[0] == 'output?'
      return print_usage() if parts.length != 1
      puts("Prefix: #{@prefix}") unless @prefix.nil?
      puts("Postfix: #{@postfix}") unless @postfix.nil?
      @mapping.keys.sort.each do |name|
        label = @mapping[name]
        puts "\"#{name}\" \"#{label}\""
      end
      return
    end
    if parts[0] == 'output-naming'
      return print_usage() if parts.length != 3
      @prefix = parts[1].length ? parts[1] : nil
      @postfix = parts[2].length ? parts[2] : nil
      return
    end
    if parts[0] == 'output'
      @mapping.clear
      @prefix = nil
      @postfix = nil
    end
    idx = 1
    while idx < parts.length
      name = parts[idx]
      src = parts[idx + 1]
      idx += 2
      puts("#{name} : #{@mapping[name]} -> #{src}") if @mapping.has_key? name
      @mapping[name] = src
    end
  end

  def command_part
    command = ''
    command.concat(",\"output-prefix\",\"#{@prefix}\"") unless @prefix.nil?
    command.concat(",\"output-postfix\",\"#{@postfix}\"") unless @postfix.nil?
    @mapping.keys.sort.each do |name|
      val = @mapping[name]
      val = "\"#{val}\"" unless val == 'null'
      command.concat ",\"output\",\"#{name}\",#{val}"
    end
    return command
  end
end
$handler['output'] = OutputHandler.new
$handler['output+'] = $handler['output']
$handler['output-naming'] = $handler['output']
$handler['output?'] = $handler['output']

class EnvHandler < Handler
  def initialize
    @usage = "env[+] [var value ...]\nenv-clear\nenv?"
    @help = "Set environment variable to value."
    @extended_help = "  Sets var to value.\n"\
      "  env+ appends to current set, env clears it first.\n"\
      "  env-clear ignores other than currently set environment.\n"\
      "  env? prints out currently set environment."
    @mapping = Hash.new
    @clear = false
  end

  def handle(parts)
    return print_usage() if (parts.length % 2) != 1
    if parts[0] == 'env?'
      puts "Restrict environment to given values."  if @clear == true
      @mapping.keys.sort.each do |name|
        value = @mapping[name]
        puts "\"#{name}\" \"#{value}\""
      end
      return
    end
    if parts[0] == 'env-clear'
      return print_usage() if parts.length != 1
      @clear = true
      return
    end
    if parts[0] == 'env'
      @mapping.clear
      @clear = false
    end
    idx = 1
    while idx < parts.length
      name = parts[idx]
      value = parts[idx + 1]
      idx += 2
      puts("#{name} : #{@mapping[name]} -> #{value}") if @mapping.has_key? name
      @mapping[name] = value
    end
  end

  def command_part
    command = @clear ? ",\"env-clear\"" : ''
    @mapping.keys.sort.each do |name|
      command.concat ",\"env\",\"#{name}\",\"#{@mapping[name]}\""
    end
    return command
  end
end
$handler['env'] = EnvHandler.new
$handler['env+'] = $handler['env']
$handler['env-clear'] = $handler['env']
$handler['env?'] = $handler['env']

class ArgHandler < Handler
  def initialize
    @usage = "arg[+] [value ...]\narg?"
    @help = "Add program arguments or print them."
    @extended_help = "  arg+ appends to current list, arg clears it first.\n"\
      "  arg? prints out current arguments."
    @args = Array.new
  end

  def handle(parts)
    if parts[0] == 'arg?'
      @args.each do |arg|
        puts "\"#{arg}\""
      end
      return
    end
    @args.clear if parts[0] == 'arg'
    @args.concat parts[1...parts.length]
  end

  def command_part
    command = ''
    @args.each do |arg|
      command.concat ",\"#{arg}\""
    end
    return command
  end
end
$handler['arg'] = ArgHandler.new
$handler['arg+'] = $handler['arg']
$handler['arg?'] = $handler['arg']

class ChannelHandler < Handler
  def initialize
    @usage = "channel in|out|err json|bytes|none\nchannel?"
    @help = "Set up channel for program run."
    @extended_help = "  First parameter selects stdin, stdout or stderr.\n"\
      "  Second parameter indicates format as JSON (data input/output), bytes,\n"\
      "  output to user but not processed in any manner or closed if none.\n"\
      "  channel? prints out the current setting."
    @channels = { 'in' => 'json', 'out' => 'json', 'err' => 'bytes' }
  end

  def handle(parts)
    if parts[0] == 'channel?'
      return print_usage() unless parts.length == 1
      @channels.keys.sort.each do |c|
        puts "#{c} #{@channels[c]}"
      end
      return
    end
    return print_usage() unless parts.length == 3
    return print_usage() unless @channels.include? parts[1]
    return print_usage() unless ['json', 'bytes', 'none'].include? parts[2]
    @channels[parts[1]] = parts[2]
  end

  def command_part
    command = ''
    @channels.keys.sort.each do |c|
      next if @channels[c] == 'none'
      direction = (c == 'in') ? 'in' : 'out'
      fmt = (@channels[c] == 'json') ? 'JSON' : @channels[c]
      command.concat ",\"channel\",\"#{direction}\",\"#{fmt}\",\"std#{c}\""
    end
    return command
  end
end
$handler['channel'] = ChannelHandler.new
$handler['channel?'] = $handler['channel']

class RunHandler < Handler
  def initialize
    @usage = "run identifier program [close]"
    @help = "Runs a program."
    @extended_help = "  Runs program using identifier closing the input if close is given.\n"\
      "  Uses current input, output, channel, env, and arg setting."
    incoming 'run'
  end

  def handle(parts)
    return print_usage() if parts.length < 3 or 4 < parts.length
    return print_usage() if parts.length == 4 and parts[3] != 'close'
    id = parts[1]
    exe = parts[2]
    command = "[\"#{id}\",\"run\""
    c = $handler['input'].command_part
    command.concat(c) unless c.empty?
    c = $handler['output'].command_part
    command.concat(c) unless c.empty?
    c = $handler['channel'].command_part
    command.concat(c) unless c.empty?
    command.concat(',"end-feed"') if parts.length == 4
    c = $handler['env'].command_part
    command.concat(c) unless c.empty?
    command.concat ",\"program\",\"#{exe}\""
    c = $handler['arg'].command_part
    command.concat(c) unless c.empty?
    command.concat ']'
    relay command
  end

  def present_other(parsed, json)
    if parsed[2] == 'bytes'
      # Turn into string using the number values and print.
      msg = ''
      parsed[3...parsed.length].each do |v|
        msg.concat v.chr
      end
      prompt_print "#{parsed[0]} bytes output:\n#{msg}"
    else
      msg = parsed[2...parsed.length].join(' ')
      prompt_print "#{parsed[0]} : #{msg}"
    end
  end
end
$handler['run'] = RunHandler.new

class PsHandler < Handler
  def initialize
    @usage = "ps"
    @help = "List running proceses."
    incoming 'processes'
  end

  def handle(parts)
    return print_usage() unless parts.length == 1
    id = $identifier.get
    $lackey.relay "[#{id},\"processes\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length < 4
    report = " PID\t: Identifier"
    parsed[3].keys.sort.each do |id|
      report.concat "\n #{parsed[3][id]}\t: #{id}"
    end
    prompt_print report
  end
end
$handler['ps'] = PsHandler.new

class KillHandler < Handler
  def initialize
    @usage = "kill identifier ..."
    @help = "Terminates processes."
    incoming 'terminate'
  end

  def handle(parts)
    return print_usage() unless parts.length > 1
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"terminate\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length < 4
    names = parsed[3...parsed.length].join(" ")
    prompt_print "Killed: #{names}"
  end
end
$handler['kill'] = KillHandler.new

class FeedHandler < Handler
  def initialize
    @usage = "feed identifier ..."
    @help = "Pass current input set to processes."
    incoming 'feed'
  end

  def handle(parts)
    return print_usage() unless parts.length > 1
    c = $handler['input'].command_part
    parts[1...parts.length].each do |procid|
      id = $identifier.get
      command = "[\"#{id}\",\"feed\",\"#{procid}\""
      command.concat(c) unless c.empty?
      command.concat ']'
      relay command
    end
  end

  def present_error(parsed, json)
    prompt_print "Process identifier not found."
  end
end
$handler['feed'] = FeedHandler.new

class EndFeedHandler < Handler
  def initialize
    @usage = "close identifier ..."
    @help = "Closes process input."
    incoming 'end-feed'
  end

  def handle(parts)
    return print_usage() unless parts.length > 1
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"end-feed\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    if parsed[2] == ''
      state = "Closed:"
    elsif parsed[2] == 'not-open'
      state = "Closed already:"
    else
      return
    end
    names = parsed[3...parsed.length].join(' ')
    prompt_print "#{state} #{names}"
  end
end
$handler['close'] = EndFeedHandler.new

class RawHandler < Handler
  def initialize
    @usage = "raw json"
    @help = "Pass unchecked JSON to datalackey."
  end

  def handle(parts)
    return print_usage() unless parts.length > 1
    relay parts[1...parts.length].join('')
  end
end
$handler['raw'] = RawHandler.new

# Load history.
history_dir = arguments.directory.nil? ? Dir.pwd : arguments.directory
history_file = File.join(history_dir, history_file_basename)
if File.exist? history_file
  fp = Pathname.new history_file
  if fp.file?
    fp.readlines.each { |line| Readline::HISTORY << line.chomp  }
  else
    puts "No history, not a file: #{history_file}"
  end
end

while not $exiting and line = Readline.readline($prompt, false)
  line.strip!
  parts = line.shellsplit
  next if parts.length == 0
  h = $handler[parts[0]]
  if h.nil?
    puts "Unknown command: #{parts[0]}"
    next
  end
  if $stdin.tty? and (Readline::HISTORY.length == 0 or Readline::HISTORY[Readline::HISTORY.length - 1] != line)
    Readline::HISTORY.push line
  end
  h.handle(parts)
end

# Ensure there is exit in case ctrl-D was pressed so that recall works.
if Readline::HISTORY.length == 0 or not Readline::HISTORY[Readline::HISTORY.length - 1].start_with? 'exit'
  Readline::HISTORY.push 'exit'
end

# Save history.
if $stdin.tty?
  begin
    fp = Pathname.new history_file
    fp.open('w') do |f|
      Readline::HISTORY.to_a.last(history_file_max_lines).each { |l| f.puts l }
    end
  rescue Errno::EACCES
    puts "Failed to write history to: #{history_file}"
  end
end

$lackey.finish
$lackey.wait_output
$presenter.wait_output
puts() unless $exiting
puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit $handler['exit'].code
