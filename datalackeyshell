#!/usr/bin/env ruby

# Argument handling and checking
# datalackey process
# Presenting command output
# Notification presenters
# Command handlers
# Run command handlers

require 'optparse'
require 'readline'
require 'shellwords'
require 'open3'
require 'json'
require 'set'
require 'pathname'

$version = 1
history_file_basename = '.datalackeyshell.history'
history_file_max_lines = 2000

# Argument handling and checking

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
  end

  def parse(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyshell [options]"
      opts.separator ""
      opts.separator "Options:"
      opts.on("-m", "--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("-d", "--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit
      end
      opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("-p", "--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
    end
    parser.parse!(args)
    # Perform sanity checks on the values.
    if @memory and not (@directory.nil? and @permissions.nil?)
      puts "Cannot use both --memory and --directory or --permissions."
      exit
    end
    if not @memory
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      @permissions = "600" if @permissions == nil
    end
  end
end

arguments = Arguments.new
arguments.parse(ARGV)

exe = arguments.lackey
if exe == nil
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  for k in 0 ... dirs.length
    exe = File.join(dirs[k], "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  puts("datalackey not found.") if exe == nil
else
  if not File.exist?(exe) or not File.executable?(exe)
    puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe == nil

# datalackey process

class LackeyProcess
  attr_reader :exit_code, :stdout, :stderr
  attr_accessor :echo

  def initialize(exe, directory, permissions, memory)
    @echo = false
    @accum_stdout = []
    @ready_stdout = Queue.new
    @unwanted_stderr = Queue.new
    args = [ exe,
        '--command-in', 'stdin', 'JSON', '--command-out', 'stdout', 'JSON' ]
    args.push('--memory') if memory
    args.concat([ '--directory', directory ]) if directory != nil
    args.concat([ '--permissions', permissions ]) if not memory
    @stdin, @stdout, @stderr, @wait_thread = Open3.popen3(*args)
    @read_stdout = Thread.new do
      while true do
        begin
          raw = @stdout.readpartial(32768)
        rescue EOFError
          break
        end
        loc = raw.index("\n")
        until loc.nil? do
          @accum_stdout.push(raw[0, loc]) if loc > 0 # Newline begins?
          # Found full line that is not empty.
          @ready_stdout.push(@accum_stdout.join) if @accum_stdout.length
          @accum_stdout.clear
          raw = raw[loc + 1, raw.length - loc - 1]
          loc = raw.index("\n")
        end
        @accum_stdout.push(raw) if raw.length > 0
      end
      @stdout.close
    end
    @read_stderr = Thread.new do
      while true do
        begin
          raw = @stderr.readpartial(32768)
        rescue EOFError
          break
        end
        # There should be nothing so no sweat on processing.
        @unwanted_stderr.push(raw)
      end
      @stderr.close
    end
  end

  def relay(message)
    @stdin.write message
    puts(message) if @echo
  end

  def reset
    @stdin.putc 0
  end

  def finish
    @stdin.close
    @wait_thread.join
    @exit_code = @wait_thread.value.exitstatus
  end

  def wait_output
    @read_stdout.join
    @read_stderr.join
  end

  def get_output
    return nil if @ready_stdout.empty?
    return @ready_stdout.pop
  end

  def get_lackey_error
    return nil if @unwanted_stderr.empty?
    return @unwanted_stderr.pop
  end
end

$lackey = LackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)

# Presenting command output

$prompt = '> '
def reprompt
  print $prompt
  STDOUT.flush
  Readline.redisplay
end

def prompt_print(message)
  puts
  puts message
  reprompt
end

class OutputPresenter
  attr_accessor :echo

  def initialize
    @handlers = Hash.new(nil)
    @present_output = Thread.new do
      last_stderr = false
      had_output = false
      until $lackey.stdout.closed? and $lackey.stderr.closed?
        had_output = false
        while out = $lackey.get_output
          break if out.nil?
          puts(out) if @echo
          arr = JSON.parse(out)
          handler = @handlers[arr[1]]
          break if handler.nil?
          handler.present(arr, out)
          last_stderr = false
          had_output = true
        end
        while out = $lackey.get_lackey_error
          break if out.nil?
          head = last_stderr ? '' : 'STDERR:'
          prompt_print head + out
          last_stderr = true
          had_output = true
        end
        sleep(0.1) unless had_output
      end
    end
  end

  def handle(command, handler)
    @handlers[command] = handler
  end

  def wait_output
    @present_output.join
  end
end
$presenter = OutputPresenter.new

class IdentifierGenerator
  def initialize
    @last = 0
  end

  def get
    @last += 1
    return @last
  end
end
$identifier = IdentifierGenerator.new

# Notification presenters

class PresentError
  def initialize
    $presenter.handle('error', self)
  end

  def present(parsed, json)
    prompt_print "Datalackey input format error, resetting stream."
    $lackey.reset
  end
end
$error_presenter = PresentError.new

# Command handlers

$handler = Hash.new(nil)
$exiting = false

class Handler
  def initialize(usage_text, help_text, extended_help_text=nil)
    @usage_text = usage_text
    @help_text = help_text
    @extended_help_text = extended_help_text
  end

  def help(short)
    puts "#{@usage_text} : #{@help_text}"
    puts(@extended_help_text) unless @extended_help_text.nil? or short == true
  end

  def usage
    puts "Usage: #{@usage_text}"
  end

  def incoming(identifier)
    $presenter.handle(identifier, self)
  end

  def relay(message)
    $lackey.relay(message)
  end

  def present_error(parsed, json)
    prompt_print "ERROR: " + parsed[3...parsed.length].join(" ")
  end

  def present_invalid(parsed, json)
    prompt_print "INVALID: " + parsed[3...parsed.length].join("\n")
  end

  def present_missing(parsed, json)
    prompt_print "MISSING: " + parsed[3...parsed.length].join("\n")
  end

  def present_other(parsed, json)
    start = parsed[2] == '' ? 3 : 2
    prompt_print(parsed[start...parsed.length].join("\n")) if parsed.length > 3
  end

  def present(parsed, json)
    return if parsed.length < 3
    if parsed[2] == 'error'
      present_error(parsed, json)
    elsif parsed[2] == 'invalid'
      present_invalid(parsed, json)
    elsif parsed[2] == 'missing'
      present_missing(parsed, json)
    else
      present_other(parsed, json)
    end
  end
end

class HelpHandler < Handler
  def initialize
    super('help|usage [command ...]', "Print command help or short usage.")
  end

  def handle(parts)
    short = parts[0] == 'usage'
    keys = (parts.length > 1) ? parts[1...parts.length] : $handler.keys
    keys.sort.each do |key|
      if $handler.include? key
        $handler[key].help(short)
      else
        puts "Unknown command: #{key}"
      end
    end
  end
end
$handler['help'] = HelpHandler.new
$handler['usage'] = $handler['help']

class ExitHandler < Handler
  attr_reader :code

  def initialize
    super("exit [code]", "Waits for datalackey to finish, exits with code.")
    @code = 0
  end

  def handle(parts)
    return usage() if parts.length > 2
    $exiting = true
    return if parts.length == 1
    begin
      @code = Integer(parts[1])
    rescue ArgumentError
      usage
      $exiting = false
    end
  end
end
$handler['exit'] = ExitHandler.new

class ListHandler < Handler
  def initialize
    super("list|ls", "Prints out the list of labels.")
    incoming 'list'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"list\"]"
  end
end
$handler['ls'] = ListHandler.new
$handler['list'] = $handler['ls']

class SetHandler < Handler
  def initialize
    super("set label value", "Sets label to JSON-encoded value", "  Enclose value in single quotes as needed, escaping any single quotes within.")
  end

  def handle(parts)
    return usage() if parts.length < 3
    v = parts[2...parts.length].join("")
    relay "{\"#{parts[1]}\":#{v}}"
  end
end
$handler['set'] = SetHandler.new

class GetHandler < Handler
  def initialize
    super("get label ...", "Gets labels.")
    incoming 'get'
  end

  def handle(parts)
    return usage() if parts.length < 2
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"get\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != ''
    head = "[#{parsed[0]},\"#{parsed[1]}\",\"\","
    prompt_print json[head.length...json.length - 1]
  end
end
$handler['get'] = GetHandler.new

class RenameHandler < Handler
  def initialize
    super("mv label new-label ...", "Re-labels values. Takes label pairs.")
    incoming 'rename'
  end

  def handle(parts)
    return usage() if (parts.length - 1) % 2 != 0
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"rename\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != 'renamed' and parsed.length != 5
    prompt_print "#{parsed[3]} -> #{parsed[4]}"
  end
end
$handler['mv'] = RenameHandler.new

class DeleteHandler < Handler
  def initialize
    super("rm label ...", "Removes labels from storage.")
  end

  def handle(parts)
    return usage() if parts.length == 1
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"delete\",\"#{names}\"]"
  end
end
$handler['rm'] = DeleteHandler.new

class StorageInfoHandler < Handler
  def initialize
    super("info", "Print information about storage.")
    incoming 'storage-info'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"storage-info\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length != 4
    puts
    parsed[3].keys.sort.each do |label|
      info = parsed[3][label]
      description = "#{label} : "
      sep = ''
      info.keys.sort.each do |format|
        description.concat "#{sep}#{format}: #{info[format]}"
        sep = ', '
      end
      puts description
    end
    reprompt
  end
end
$handler['info'] = StorageInfoHandler.new

class PingHandler < Handler
  def initialize
    super("ping", "Check that datalackey responds.")
    incoming 'no-op'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"no-op\"]"
  end

  def present_other(parsed, json)
    prompt_print "Datalackey responded."
  end
end
$handler['ping'] = PingHandler.new

class VersionHandler < Handler
  def initialize
    super("version", "Print version information.")
    incoming 'version'
  end

  def handle(parts)
    return usage() if parts.length != 1
    id = $identifier.get
    relay "[#{id},\"version\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length != 4
    description = "shell: #{$version}"
    parsed[3].keys.sort.each do |key|
      description.concat "\n#{key}: #{parsed[3][key]}"
    end
    prompt_print description
  end
end
$handler['version'] = VersionHandler.new

class EchoHandler < Handler
  def initialize
    super("echo in|out on|off", "Set printing datalackey input or output on or off.")
  end

  def handle(parts)
    return usage() unless parts.length == 3
    return usage() unless ['in', 'out'].include? parts[1]
    return usage() unless ['on', 'off'].include? parts[2]
    $lackey.echo = parts[2] == 'on' if parts[1] == 'in'
    $presenter.echo = parts[2] == 'on' if parts[1] == 'out'
  end
end
$handler['echo'] = EchoHandler.new

class NotifyHandler < Handler
  def initialize
    super("notify process|data on|off", "Turn process or data notifications on or off.")
    incoming 'process'
    incoming 'data'
    @notify = { 'process' => 'off', 'data' => 'on' }
  end

  def handle(parts)
    if parts.length != 1
      return usage() unless parts.length == 3
      return usage() unless ['process', 'data'].include? parts[1]
      return usage() unless ['on', 'off'].include? parts[2]
      @notify[parts[1]] = parts[2]
    end
    @notify.keys.sort.each do |key|
      puts "#{key} : #{@notify[key]}"
    end
  end

  def present(parsed, json)
    prompt_print "#{parsed[1].capitalize} #{parsed[2]} : #{parsed[3]}"
  end
end
$handler['notify'] = NotifyHandler.new

class HistoryHandler < Handler
  def initialize
    super("history [regex ...]", "Print commands that match any regex, or all.")
  end

  def handle(parts)
    exps = Array.new
    parts[1...parts.length].each do |e|
      exps.push Regexp.new(e)
    end
    Readline::HISTORY.take(Readline::HISTORY.length - 1).each do |h|
      match = exps.length == 0
      exps.each do |e|
        match = e.match(h)
        break if match
      end
      puts(h) if match
    end
  end
end
$handler['history'] = HistoryHandler.new

# Run command handlers

class InputHandler < Handler
  def initialize
    extra = "  Passes label as name, or value of name as given directly.\n"\
      "  Allowed values are integers and strings. Quote '\"string value\"'.\n"\
      "  input+ appends to current mapping, input clears it first."
    super("input[+] [name : label | name = value ...]", "Map input name to label/value.", extra)
    @order = Array.new
    @mapping = Hash.new
  end

  def handle(parts)
    return usage() if (parts.length % 3) != 1
    if parts[0] == 'input'
      @order.clear
      @mapping.clear
    end
    idx = 1
    while idx < parts.length
      name = parts[idx]
      return usage() unless [':', '='].include? parts[idx + 1]
      direct = parts[idx + 1] == '='
      src = parts[idx + 2]
      idx += 3
      if @mapping.has_key? name
        puts "Error: #{name} already in mapping."
        break
      end
      if direct
        begin
          check = JSON.load(src)
        rescue JSON::ParserError
          puts "Error: #{name} value is invalid: #{src}"
          break
        end
      end
      @order.push name
      @mapping[name] = [direct, src]
    end
    @order.each do |name|
      direct, val = @mapping[name]
      t = direct ? "=" : ":"
      puts "#{name} #{t} #{val}"
    end
  end

  def command_part
    command = ''
    @order.each do |name|
      direct, val = @mapping[name]
      if direct
        command.concat ",\"direct\",#{val},\"#{name}\""
      else
        command.concat ",\"input\",\"#{val}\",\"#{name}\""
      end
    end
    return command
  end
end
$handler['input'] = InputHandler.new
$handler['input+'] = $handler['input']

class OutputHandler < Handler
  def initialize
    cmds = "output[+] [label name ...]\n"\
      "output-naming prefix postfix"
    extra = "  Maps name to label. Using null as label discards that name.\n"\
      "  output+ adds to current mapping, output clears it first.\n"\
      "  output-naming sets prefix and postfix to names that have no match."
    super(cmds, "Map output name to label.", extra)
    @mapping = Hash.new
    @prefix = nil
    @postfix = nil
  end

  def handle(parts)
    return usage() if (parts.length % 2) != 1
    if parts[0] == 'output'
      @mapping.clear
      @prefix = nil
      @postfix = nil
    end
    if parts[0] == 'output-naming'
      return usage() if parts.length != 3
      @prefix = parts[1].length ? parts[1] : nil
      @postfix = parts[2].length ? parts[2] : nil
    else
      idx = 1
      while idx < parts.length
        name = parts[idx]
        src = parts[idx + 1]
        idx += 2
        if @mapping.has_key? name
          old = @mapping[name]
          puts "Overwrote #{name} old value #{old} with #{src}"
        end
        @mapping[name] = src
      end
    end
    puts("Prefix: #{@prefix}") unless @prefix.nil?
    puts("Postfix: #{@postfix}") unless @postfix.nil?
    @mapping.keys.sort.each do |name|
      label = @mapping[name]
      puts "\"#{name}\" \"#{label}\""
    end
  end

  def command_part
    command = ''
    if not @prefix.nil?
      command = ",\"output-prefix\",\"#{@prefix}\""
    end
    if not @postfix.nil?
      command = ",\"output-postfix\",\"#{@postfix}\""
    end
    @mapping.keys.sort.each do |name|
      val = @mapping[name]
      val = "\"#{val}\"" unless val == 'null'
      command.concat ",\"output\",\"#{name}\",#{val}"
    end
    return command
  end
end
$handler['output'] = OutputHandler.new
$handler['output+'] = $handler['output']
$handler['output-naming'] = $handler['output']

class EnvHandler < Handler
  def initialize
    extra = "  Sets var to value.\n"\
      "  env+ appends to current set, env clears it first.\n"\
      "  env-clear ignores other than currently set environment."
    super("env[+] [var value ...]\nenv-clear", "Set environment variable to value.", extra)
    @mapping = Hash.new
    @clear = false
  end

  def handle(parts)
    return usage() if (parts.length % 2) != 1
    if parts[0] == 'env'
      @mapping.clear
      @clear = false
    end
    if parts[0] == 'env-clear'
      return usage() if parts.length != 1
      @clear = true
    else
      idx = 1
      while idx < parts.length
        name = parts[idx]
        value = parts[idx + 1]
        idx += 2
        if @mapping.has_key? name
          old = @mapping[name]
          puts "Overwrote #{name} value #{old} with #{value}"
        end
        @mapping[name] = value
      end
    end
    puts "Restrict environment to given values."  if @clear == true
    @mapping.keys.sort.each do |name|
      value = @mapping[name]
      puts "\"#{name}\" \"#{value}\""
    end
  end

  def command_part
    command = @clear ? ",\"env-clear\"" : ''
    @mapping.keys.sort.each do |name|
      val = @mapping[name]
      command.concat ",\"env\",\"#{name}\",\"#{val}\""
    end
    return command
  end
end
$handler['env'] = EnvHandler.new
$handler['env+'] = $handler['env']
$handler['env-clear'] = $handler['env']

class ArgsHandler < Handler
  def initialize
    extra = "  args+ appends to current list, args clears it first."
    super("args[+] [value ...]", "Add program arguments.", extra)
    @args = Array.new
  end

  def handle(parts)
    if parts[0] == 'args'
      @args.clear
    end
    @args.concat parts[1...parts.length]
    @args.each do |arg|
      puts "\"#{arg}\""
    end
  end

  def command_part
    command = ''
    @args.each do |arg|
      command.concat ",\"#{arg}\""
    end
    return command
  end
end
$handler['args'] = ArgsHandler.new
$handler['args+'] = $handler['args']

class ChannelHandler < Handler
  def initialize
    extra = "  First parameter selects stdin, stdout or stderr.\n"\
      "  Second parameter indicates format as JSON (data input/output), bytes,\n"\
      "  output to user but not processed in any manner or closed if none.\n"\
      "  channel? prints out the current setting."
    super("channel in|out|err json|bytes|none\nchannel?", "Set up channel for program run.", extra)
    @channels = { 'in' => 'json', 'out' => 'json', 'err' => 'bytes' }
  end

  def handle(parts)
    if parts[0] == 'channel?'
      return usage() unless parts.length == 1
    else
      return usage() unless parts.length == 3
      return usage() unless ['in', 'out', 'err'].include? parts[1]
      return usage() unless ['json', 'bytes', 'none'].include? parts[2]
      @channels[parts[1]] = parts[2]
    end
    @channels.keys.sort.each do |c|
      puts "#{c} #{@channels[c]}"
    end
  end

  def command_part
    command = ''
    @channels.keys.sort.each do |c|
      next if @channels[c] == 'none'
      direction = (c == 'in') ? 'in' : 'out'
      fmt = (@channels[c] == 'json') ? 'JSON' : @channels[c]
      command.concat ",\"channel\",\"#{direction}\",\"#{fmt}\",\"std#{c}\""
    end
    return command
  end
end
$handler['channel'] = ChannelHandler.new
$handler['channel?'] = $handler['channel']

class RunHandler < Handler
  def initialize
    extra = "  Runs program using identifier closing the input if eof is given.\n"\
      "  Uses current input, output, channel, env, and args setting."
    super("run identifier program [eof]", "Runs a program.", extra)
    incoming 'run'
  end

  def handle(parts)
    return usage() if parts.length < 3 or 4 < parts.length
    return usage() if parts.length == 4 and parts[3] != 'eof'
    id = parts[1]
    exe = parts[2]
    eof = parts.length == 4
    command = "[\"#{id}\",\"run\""
    c = $handler['input'].command_part
    command.concat(c) unless c.empty?
    c = $handler['output'].command_part
    command.concat(c) unless c.empty?
    c = $handler['channel'].command_part
    command.concat(c) unless c.empty?
    command.concat(',"end-feed"') if eof
    c = $handler['env'].command_part
    command.concat(c) unless c.empty?
    command.concat ",\"program\",\"#{exe}\""
    c = $handler['args'].command_part
    command.concat(c) unless c.empty?
    command.concat ']'
    relay command
  end

  def present_other(parsed, json)
    if parsed[2] == 'bytes'
      # Turn into string using the number values and print.
      msg = ''
      parsed[3...parsed.length].each do |v|
        msg.concat v.chr
      end
      prompt_print "#{parsed[0]} bytes output:\n#{msg}"
    else
      msg = parsed[2...parsed.length].join(' ')
      prompt_print "#{parsed[0]} : #{msg}"
    end
  end
end
$handler['run'] = RunHandler.new

class PsHandler < Handler
  def initialize
    super("ps", "List running proceses.")
    incoming 'processes'
  end

  def handle(parts)
    return usage() unless parts.length == 1
    id = $identifier.get
    $lackey.relay "[#{id},\"processes\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length < 4
    report = 'Identifier : pid'
    parsed[3].keys.sort.each do |id|
      report.concat "\n#{id} : #{parsed[3][id]}"
    end
    prompt_print report
  end
end
$handler['ps'] = PsHandler.new

class KillHandler < Handler
  def initialize
    super("kill identifier ...", "Terminates processes.")
    incoming 'terminate'
  end

  def handle(parts)
    return usage() unless parts.length > 1
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"terminate\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length < 4
    names = parsed[3...parsed.length].join(" ")
    prompt_print "Killed: #{names}"
  end
end
$handler['kill'] = KillHandler.new

class FeedHandler < Handler
  def initialize
    super("feed identifier ...", "Pass current input set to processes.")
    incoming 'feed'
  end

  def handle(parts)
    return usage() unless parts.length > 1
    c = $handler['input'].command_part
    parts[1...parts.length].each do |procid|
      id = $identifier.get
      command = "[\"#{id}\",\"feed\",\"#{procid}\""
      command.concat(c) unless c.empty?
      command.concat ']'
      relay command
    end
  end

  def present_error(parsed, json)
    prompt_print "Process identifier not found."
  end
end
$handler['feed'] = FeedHandler.new

class EndFeedHandler < Handler
  def initialize
    super("close identifier ...", "Closes process input.")
    incoming 'end-feed'
  end

  def handle(parts)
    return usage() unless parts.length > 1
    id = $identifier.get
    names = parts[1...parts.length].join('","')
    relay "[#{id},\"end-feed\",\"#{names}\"]"
  end

  def present_other(parsed, json)
    if parsed[2] == ''
      state = "Closed:"
    elsif parsed[2] == 'not-open'
      state = "Closed already:"
    else
      return
    end
    names = parsed[3...parsed.length].join(' ')
    prompt_print "#{state} #{names}"
  end
end
$handler['close'] = EndFeedHandler.new

class RawHandler < Handler
  def initialize
    super("raw json", "Pass unchecked JSON to datalackey.")
  end

  def handle(parts)
    return usage() unless parts.length > 1
    relay parts[1...parts.length].join('')
  end
end
$handler['raw'] = RawHandler.new

# Load history.
history_dir = arguments.directory.nil? ? Dir.pwd : arguments.directory
history_file = File.join(history_dir, history_file_basename)
if File.exist? history_file
  fp = Pathname.new history_file
  if fp.file?
    fp.readlines.each { |line| Readline::HISTORY << line.chomp  }
  else
    puts "No history, not a file: #{history_file}"
  end
end

while line = Readline.readline($prompt, false)
  line.strip!
  parts = line.shellsplit
  next if parts.length == 0
  h = $handler[parts[0]]
  if h.nil?
    puts "Unknown command: #{parts[0]}"
    next
  end
  if Readline::HISTORY.length == 0 or Readline::HISTORY[Readline::HISTORY.length - 1] != line
    Readline::HISTORY.push line
  end
  h.handle(parts)
  break if $exiting

  # Run helper commands.
  # recall program input output channel env args Fetches value from
  #  last run of program, without argumets fetches all.
  # re-run program ... Like "recall program ..." and "run program" so uses
  #  current for parts that have not been recalled.
  #  recall allows for editing values, re-run direct re-use
end

# Save history.
begin
  fp = Pathname.new history_file
  fp.open('w') do |f|
    Readline::HISTORY.to_a.last(history_file_max_lines).each { |l| f.puts l }
  end
rescue Errno::EACCES
  puts "Failed to write history to: #{history_file}"
end

$lackey.finish
$lackey.wait_output
$presenter.wait_output
puts() unless $exiting
puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit $handler['exit'].code
