#!/usr/bin/env ruby

# Argument handling and checking
# datalackey process
# Presenting command output
# Notification presenters
# Command handlers
# Run command handlers

require 'optparse'
require 'readline'
require 'shellwords'
require 'open3'
require 'json'
require 'yaml'
require 'set'
require 'pathname'
require 'io/console'

$version = 1
history_file_basename = '.datalackeyshell.history'
history_file_max_lines = 2000
$echo_lackey_output = false
$command_echo = false

# Argument handling and checking

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions

  def initialize
    @directory = nil
    @memory = nil
    @lackey = nil
    @permissions = nil
  end

  def parse(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyshell [options]"
      opts.separator ""
      opts.separator "Options:"
      opts.on("-m", "--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("-d", "--directory [DIR]",
          "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit 0
      end
      opts.on("-l", "--lackey PROGRAM",
          "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("-p", "--permissions MODE", [:user, :group, :other],
          "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
      opts.on('-e', '--echo', 'Turn datalackey command and reply encho on.') do
        $echo_lackey_output = true
        $command_echo = true
      end
    end
    parser.parse!(args)
    # Perform sanity checks on the values.
    if not @memory.nil? and not (@directory.nil? and @permissions.nil?)
      STDERR.puts "Cannot use both --memory and --directory or --permissions."
      exit 1
    end
    if @memory.nil?
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        STDERR.puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      if permissions.nil?
        if (File.umask & 077) == 0
          @permissions = '666'
        elsif (File.umask & 070) == 0
          @permissions = '660'
        else
          @permissions = "600"
        end
      end
    end
  end
end

arguments = Arguments.new
arguments.parse(ARGV)

exe = arguments.lackey
if exe.nil?
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  dirs.each do |d|
    exe = File.join(d, "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  puts("datalackey not found.") if exe.nil?
else
  if not File.exist?(exe) or not File.executable?(exe)
    STDERR.puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe.nil?

# datalackey process

require './datalackey-lib.rb'

$lackey = DatalackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)
stderr_discarder = DiscardReader.new($lackey.stderr)
$lackey_io = DatalackeyIO.new($lackey.stdin, $lackey.stdout)

# Presenting command output

def indent_puts(long)
  rows, cols = IO.console.winsize
  if long.length < cols or long.include? '\n'
    puts long
    return
  end
  pieces = long.split
  line = pieces.first
  for k in 1 ... pieces.length
    if line.length + 1 + pieces[k].length <= cols
      line << ' ' << pieces[k]
      next
    end
    puts line
    line = '  ' + pieces[k]
  end
  puts line
end

$prompt = '> '
def reprompt
  return unless $stdin.tty?
  print $prompt
  $stdout.flush
  Readline.redisplay
end

def prompt_print(message)
  puts() if $stdin.tty?
  indent_puts message
  reprompt
end

$default_message_proc = Proc.new do |category, action, message, vars|
  out = []
  out.push(message.to_s) if $echo_lackey_output
  case category
  when :error, 'error'
    out.push "ERROR #{action} : #{message.join(' ')}"
  when :data, 'data'
    out.push "#{action} : #{vars.first}"
  when :process, 'process'
    case action
    when :ended, 'ended'
    else
      out.push "#{action} : #{vars.first}"
    end
  when :return, 'return'
    case action
    when :done, 'done'
    else
      out.push("#{action} : #{vars.join(' ')}") unless vars.empty?
    end
  else
    out.push "#{category} / #{action} : #{vars.join(' ')}"
  end
  out
end

class OutputPresenter
  def initialize
    @present_output = Thread.new do
      until $lackey_io.closed?
        msgs = $lackey_io.get_messages
        if msgs.empty?
          sleep(0.1)
          next
        end
        puts
        msgs.each { |msg| puts msg }
        reprompt
      end
    end
  end

  def finish
    @present_output.join
  end
end
$presenter = OutputPresenter.new

# Command handlers

$handler = Hash.new(nil)
$exiting = false

class Handler

  def syntax_array_requirements(arr)
    return [ arr, arr.length, false ] unless arr.first.is_a? Integer
    alternatives = false
    required = arr.first
    arr = arr[1...arr.length]
    if required < 0
      required = arr.length
      alternatives = true
    end
    return arr, required, alternatives
  end

  def construct_usages(result, value, seen = [])
    if value.is_a? Array
      value, required, alternatives = syntax_array_requirements(value)
      prev = nil
      value.each_index do |k|
        alt = value[k]
        if alternatives and 0 < k
          result.push(prev.is_a?(Array) ? ' || ' : '|')
        elsif prev.is_a? String
          result.push ' '
        elsif prev.is_a? Symbol
          result.push(' ') unless result.last == '[' or result.last == '|'
        end
        result.push('[') if 0 < required and k == required
        prev = alt
        construct_usages(result, alt, seen)
      end
      result.pop() if result.last == '|'
      result.push(']') if 0 < required and required < value.length
      return result
    end
    if seen.include? value
      result.push '...'
      return result
    end
    if @syntax.has_key? value
      seen.push value
      construct_usages(result, @syntax[value], seen)
      seen.pop
      return result
    end
    result.push value.to_s
    return result
  end

  def usages
    top = @syntax[:root]
    return { :root => [ top ] } if top.is_a? String # Parameterless command.
    results = { }
    if top.first.is_a? Integer and top[1].is_a? String or top.first.is_a? String
      results[:root] = construct_usages([], :root)
    else # Command with variations. Expect array of arrays of symbol(s).
      top = top[1...top.length] if top.first.is_a? Integer
      top.each { |sym| results[sym] = construct_usages([], sym) }
    end
    return results
  end

  def print_help
    msgs = []
    usages.each_pair do |key, value|
      m = "#{value.join}"
      m.concat(" : #{@syntax[:help][key]}") if @syntax[:help].include? key
      msgs.push m
    end
    msgs.sort.each { |m| indent_puts m }
  end

  def completion_search(suggestions, parts, part_idx, key, item)
    return true if part_idx >= parts.length
    last = part_idx + 1 == parts.length
    if item.is_a? Symbol # These either validate part or add suggestions.
      cands = nil
      case item
      when :command
        cands = $handler.keys
      when :label
        cands = $lackey_io.data.keys
      when :process_id
        cands = $lackey_io.process.keys
      when :history_process_id
        cands = [] # Run command identifiers from history.
        scan_history([ Regexp.new('^run[[:blank:]]+') ]).each do |h|
          pieces = h.shellsplit
          cands.push(pieces[1]) if 1 < pieces.length
        end
      when :executable
        return File.executable?(parts[part_idx]) unless last
        cands = Dir[parts.last + '*'].grep(/^#{Regexp.escape(parts.last)}/)
      when :string
        return true # Anything goes.
      when :int
        begin
          Integer(parts[part_idx])
          return true # Any integer is fine.
        rescue ArgumentError
          return false
        end
      when :null
        # Requires that :null is before :string in allowed values.
        return $null_handler.null == parts[part_idx] unless last
        cands = [ $null_handler.null ]
      when :varname
        return not(parts[part_idx].include?('=')) unless last
        cands = []
      else
        return completion_search(suggestions, parts, part_idx, item, @syntax[item])
      end
      return false if cands.nil?
      return cands.include?(parts[part_idx]) unless last
      suggestions.concat cands
      return true
    elsif item.is_a? String
      return item == parts[part_idx] unless last
      suggestions.push item
      return true
    elsif item.is_a? Array
      item, required, ored = syntax_array_requirements(item)
      ok = true
      item.each_index do |k|
        sub = item[k]
        res = completion_search(suggestions, parts, part_idx, key, sub)
        ok = (ored ? (ok or res) : (required <= k ? ok : res))
        break unless ok or ored
        part_idx = part_idx + 1 unless ored
      end
      return ok
    end
    raise ArgumentError.new('Item other than nil, Symbol, String or Array.')
  end

  def completion_candidates(parts, str)
    suggestions = []
    parts.push('') if str.empty?
    completion_search(suggestions, parts, 0, :root, @syntax[:root])
    return suggestions.grep(/^#{Regexp.escape(str)}/).sort.uniq
  end

  def pop_false(match, condition)
    match.pop() unless condition
    return condition
  end

  def verify_search(match, parts, key, item)
    print match, parts, key, item
    puts
    return nil if match.length == parts.length
    part = parts[match.length]
    last = match.length + 1 == parts.length
    if item.is_a? Symbol # These either validate part or add suggestions.
      match.push item
      case item
      when :command
        return pop_false(match, $handler.has_key?(part))
      when :label
        return pop_false(match, $lackey_io.data.has_key?(part))
      when :process_id
        return pop_false(match, $lackey_io.process.has_key?(part))
      when :history_process_id
        scan_history([ Regexp.new('^run[[:blank:]]+') ]).each do |h|
          pieces = h.shellsplit
          return true if pieces.length >= 2 and pieces[1] == part
        end
        return pop_false(match, false)
      when :executable
        return pop_false(match, File.executable?(part))
      when :string
        return true # Anything goes.
      when :int
        begin
          Integer(part)
          return true # Any integer is fine.
        rescue ArgumentError
          return pop_false(match, false)
        end
      when :null
        nv = $null_handler.null
        return pop_false(match, nv == part)
      when :varname
        return pop_false(match, not(part.include?('=')))
      end
      match.pop
      return verify_search(match, parts, item, @syntax[item])
    elsif item.is_a? String
      match.push item
      return pop_false(match, item == part)
    elsif item.is_a? Array
      item, required, alternatives = syntax_array_requirements(item)
      required = 1 if alternatives
      return false if parts.length < match.length + required
      orig_count = match.length
      item.each_index do |k|
        sub = item[k]
        ok = verify_search(match, parts, key, sub)
        return nil if ok.nil?
        if alternatives
          return true if ok # One match is enough.
          next
        elsif not ok
          if k < required # Looking for required consecutive matches.
            match.pop(match.length - orig_count)
            return false
          elsif required == 0
            return false # Optional repeating element not matched. Don't recurse.
          end
        end
      end
      return true unless alternatives
      match.pop(match.length - orig_count)
      return false
    end
    raise ArgumentError.new('Item other than nil, Symbol, String or Array.')
  end

  def verify(parts)
    top = @syntax[:root]
    return (parts.length == 1 and parts[0] == top) if top.is_a? String
    match = []
    return false unless verify_search(match, parts, :root, top).nil?
    # Convert according to match information as needed.
    parts.each_index do |k|
      case match[k]
      when :null
        parts[k] = nil
      when :int
        parts[k] = Integer(parts[k])
      end
    end
    return true
  end

  def register_search
    # Currently it holds that the strings are at top level first or second
    # level first items.
    top = @syntax[:root]
    return [ top ] if top.is_a? String
    raise ArgumentError.new('Not String or Array.') unless top.is_a? Array
    items, required, search_children = syntax_array_requirements(top)
    return [ items.first ] unless search_children
    cmds = []
    items.each do |item|
      sub = @syntax[item]
      if sub.is_a? String
        cmds.push sub
        next
      end
      sub, required, wrong_assumption = syntax_array_requirements(sub)
      raise ArgumentError.new('Alternatives at level 2') if wrong_assumption
      raise ArgumentError.new('Symbol at level 2') unless sub.first.is_a? String
      cmds.push sub.first
    end
    return cmds.uniq
  end

  def register
    register_search.each do |cmd|
      raise KeyError.new("Command in handlers: #{cmd}") if $handler.has_key? cmd
      $handler[cmd] = self
    end
  end

  def send(patt_act, message, user_id = false)
    $lackey_io.send(patt_act, message, user_id, $command_echo ? $stdout : nil)
  end

  def dump(json_as_string)
    $lackey_io.dump(json_as_string, $command_echo ? $stdout : nil)
  end

  def present_other(parsed, json)
    start = parsed[2] == '' ? 3 : 2
    prompt_print(parsed[start...parsed.length].join("\n")) if parsed.length > 3
  end

  def present(parsed, json)
    return if parsed.length < 3
    present_other(parsed, json)
  end
end

class HelpHandler < Handler
  def initialize
    @syntax = {
      :root => [ 1, 'help', :cmds ],
      :cmds => [ 0, :command, :cmds ],
      :help => { :root => "Print command help." }
    }
    register
  end

  def handle(parts)
    printed = Set.new
    keys = (parts.length > 1) ? parts[1...parts.length] : $handler.keys
    keys.sort.each do |key|
      if $handler.include? key
        object = $handler[key]
        next if printed.include? object
        printed.add object
        object.print_help
      else
        puts "Unknown command: #{key}"
      end
    end
  end
end
#$handler['help'] = HelpHandler.new
HelpHandler.new

class ExitHandler < Handler
  attr_reader :code

  def initialize
    @syntax = {
      :root => [ 1, 'exit', :int ],
      :help => { :root => "Waits for datalackey to finish, exits with code." }
    }
    @code = 0
    register
  end

  def handle(parts)
    $exiting = true
    @code = parts[1] if parts.length == 2
  end
end
$exit_handler = ExitHandler.new

class NullHandler < Handler
  attr_reader :null

  def initialize
    @syntax = {
      :root => [ -1, :nullcmd, :nullcmdwhat ],
      :nullcmd => [ 'null', :string ],
      :nullcmdwhat => 'null?',
      :help => {
        :nullcmd => "Sets string that is interpreted as null when null is allowed.",
        :nullcmdwhat => "Prints out string that is interpreted as null."
      }
    }
    @null = 'null'
    register
  end

  def handle(parts)
    if parts.length == 2
      @null = parts.last
    else
      puts "String interpreted as null is: '#{@null}'"
    end
  end
end
$null_handler = NullHandler.new

class ListHandler < Handler
  def initialize
    @syntax = {
      :root => [ 1, 'ls', :regexps ],
      :regexps => [ 0, :string, :regexps ],
      :help => { :root => "Prints out the list of data labels that match optional regular expressions." }
    }
    register
  end

  def handle(parts)
    clean = parts[1...parts.length].sort.uniq
    exps = []
    clean.each { |e| exps.push Regexp.new(e) }
    $lackey_io.data.keys.sort.each do |label|
      match = exps.length == 0
      exps.each do |e|
        match = e.match(label)
        break if match
      end
      puts(label) if match
    end
  end
end
ListHandler.new

class SetHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'set', :string, :string ],
      :help => { :root => "Sets label to JSON-encoded value (in single quotes as needed)." }
    }
    register
  end

  def handle(parts)
    v = parts[2...parts.length].join("")
    dump "{\"#{parts[1]}\":#{v}}"
  end
end
SetHandler.new

class GetHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'get', :label, :labels ],
      :labels => [ 0, :label, :labels ],
      :help => { :root => "Gets labels." }
    }
    pretty_print = Proc.new do |category, action, message, vars|
      out = []
      out.push(message.to_s) if $echo_lackey_output
      out.push JSON.pretty_generate(message.last) if category == :return
      out
    end
    @actions = PatternAction.new([{
      :return => [ { :get => [ '@', 'get', '', '?' ] } ],
      :error => [ { :get_fail => [ '@', 'get', 'failed', '*' ] } ]
    }], [ pretty_print, $default_message_proc ])
    register
  end

  def handle(parts)
    send(@actions, [ 'get' ].concat(parts[1...parts.length]))
  end
end
GetHandler.new

class RenameHandler < Handler
  def initialize
    @syntax = {
      :root => [ 2, 'mv', :label_pair, :label_pairs ],
      :label_pairs => [ 0, :label_pair, :label_pairs ],
      :label_pair => [ :label, :string ],
      :help => { :root => "Re-labels values. Takes label and new name pairs." }
    }
    @actions = PatternAction.new([{
      :note => [ { :missing => [ '@', 'rename', 'missing', '*' ] } ]
    }], [ $default_message_proc ])
    register
  end

  def handle(parts)
    send(@actions, [ 'rename' ].concat(parts[1...parts.length]))
  end
end
RenameHandler.new

class DeleteHandler < Handler
  def initialize
    @syntax = {
      :root => [ 2, 'rm', :label, :labels ],
      :labels => [ 0, :label, :labels ],
      :help => { :root => "Removes labels from storage." }
    }
    @actions = PatternAction.new([{
      :note => [ { :missing => [ '@', 'delete', 'missing', '*' ] } ]
    }], [ $default_message_proc ])
    register
  end

  def handle(parts)
    send(@actions, [ 'delete' ].concat(parts[1...parts.length]))
  end
end
DeleteHandler.new

class StorageInfoHandler < Handler
  def initialize
    @syntax = {
      :root => 'info',
      :help => { :root => "Print information about storage." }
    }
    present = Proc.new do |category, action, message, vars|
      out = []
      message.last.keys.sort.each do |label|
        info = message.last[label]
        description = "#{label} : "
        sep = ''
        info.keys.sort.each do |format|
          description.concat "#{sep}#{format}: #{info[format]}"
          sep = ', '
        end
        out.push description
      end
      out
    end
    @actions = PatternAction.new([{
      :return => [ { 'storage-info' => [ '@', 'storage-info', '', '?' ] } ]
    }], [ present, $default_message_proc ])
    register
  end

  def handle(parts)
    send(@actions, [ 'storage-info' ])
  end
end
StorageInfoHandler.new

class PingHandler < Handler
  def initialize
    @syntax = {
      :root => 'ping',
      :help => { :root => "Check that datalackey responds." }
    }
    @actions = PatternAction.new([{
      :return => [ { :done => [ '@', 'no-op', '' ] } ]
    }], [ $default_message_proc ])
    register
  end

  def handle(parts)
    tracker = send(@actions, [ 'no-op' ])
    if tracker.nil?
      puts("No connection to datalackey.")
      return
    end
    puts(tracker.status ? "Datalackey responded." : "Error occurred.")
  end
end
PingHandler.new

class VersionHandler < Handler
  def initialize
    @syntax = {
      :root => 'version',
      :help => { :root => "Print version information." }
    }
    register
  end

  def handle(parts)
    description = "shell: #{$version}"
    v = $lackey_io.version
    v.keys.sort.each { |key| description.concat "\n#{key}: #{v[key]}" }
    puts description
  end
end
VersionHandler.new

class EchoHandler < Handler
  def initialize
    @syntax = {
      :root => [ -1, :lackey, :lackeywhat ],
      :lackey => [ 'lackey', :inout, :onoff ],
      :lackeywhat => 'lackey?',
      :inout => [ -1, 'command', 'reply' ],
      :onoff => [ -1, 'on', 'off' ],
      :help => {
        :lackey => "Set the printing of communication with datalackey on or off.",
        :lackeywhat => "Print datalackey command/reply printing status."
      }
    }
    register
  end

  def handle(parts)
    if parts.length > 1
      $command_echo = parts[2] == 'on' if parts[1] == 'command'
      $echo_lackey_output = parts[2] == 'on' if parts[1] == 'reply'
    else
      puts "command: #{$command_echo ? 'on' : 'off'}"
      puts "reply  : #{$echo_lackey_output ? 'on' : 'off'}"
    end
  end
end
EchoHandler.new

def scan_history(regexps)
  matched = Array.new
  Readline::HISTORY.take(Readline::HISTORY.length - 1).each do |h|
    match = regexps.length == 0
    regexps.each do |e|
      match = e.match(h)
      break if match
    end
    matched.push(h) if match
  end
  return matched
end

class HistoryHandler < Handler
  def initialize
    @syntax = {
      :root => [ 1, 'history', :regexps ],
      :regexps => [ 0, :string, :regexps ],
      :help => { :root => "Print commands that match any regex, or all." }
    }
    register
  end

  def handle(parts)
    exps = []
    parts[1...parts.length].each { |e| exps.push Regexp.new(e) }
    scan_history(exps).each { |h| puts h }
  end
end
HistoryHandler.new

class RecallHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'recall', :history_process_id ],
      :help => { :root => "Fetch last \"run identifier\" related settings from history. Finds the input, output, env, arg, and channel settings that were in effect when last run with given identifier was done. If no identifier is given, last run command identifier is used. Prints the lines found from history." }
    }
    register
  end

  def scan_until_first(new_to_old, exps)
    regexps = []
    exps.each { |e| regexps.push Regexp.new(e) }
    matches = []
    new_to_old.each do |c|
      for k in 0...regexps.length
        next unless regexps[k].match(c)
        matches.push(c)
        return matches if k == 0
        break
      end
    end
    return matches
  end

  def print_until_first(new_to_old, exps)
    n2o = scan_until_first(new_to_old, exps)
    while not n2o.empty?
      puts n2o.pop
    end
  end

  def handle(parts)
    id_given = parts.length == 2
    es = [ '^input[+]?[[:blank:]]+', '^output[+]?[[:blank:]]+',
      '^arg[+]?[[:blank:]]+', '^env[+]?[[:blank:]]+', '^env-clear$',
      '^channel[[:blank:]]+', '^exit' ]
    es.push('^run[[:blank:]]+' + (id_given ? parts[1] + '[[:blank:]]+' : ''))
    exps = Array.new
    es.each { |e| exps.push Regexp.new(e) }
    candidates = scan_history(exps)
    # Drop everything after the last matching run command.
    while not candidates.empty? and not candidates.last.start_with? 'run'
      candidates.pop
    end
    # Pick commands before last exit. Reverses order.
    session = Array.new
    while not candidates.empty? and not candidates.last.start_with? 'exit'
      session.push candidates.pop
    end
    print_until_first(session, [ '^channel[[:blank:]]+in[[:blank:]]' ])
    print_until_first(session, [ '^channel[[:blank:]]+out[[:blank:]]' ])
    print_until_first(session, [ '^channel[[:blank:]]+err[[:blank:]]' ])
    print_until_first(session, [ '^env[[:blank:]]', '^env[+][[:blank:]]', '^env-clear$' ])
    print_until_first(session, [ '^arg[[:blank:]]', '^arg[+][[:blank:]]' ])
    print_until_first(session, [ '^input[[:blank:]]', '^input[+][[:blank:]]' ])
    print_until_first(session, [ '^output[[:blank:]]', '^output[+][[:blank:]]', '^output-naming[[:blank:]]' ])
  end
end
RecallHandler.new

# Run command handlers

class NotifyHandler < Handler
  def initialize
    @syntax = {
      :root => [ -1, :notify, :notifywhat ],
      :notify => [ 'notify', :procdata, :onoff ],
      :notifywhat => 'notify?',
      :procdata => [ -1, 'data', 'process' ],
      :onoff => [ -1, 'on', 'off' ],
      :help => {
        :notify => "Turn process or data notifications on or off.",
        :notifywhat => "Print data/process notification status."
      }
    }
    @notify = { 'process' => 'off', 'data' => 'on' }
    register
  end

  def handle(parts)
    if parts.length > 1
      @notify[parts[1]] = parts[2]
    else
      @notify.keys.sort.each { |key| puts "#{key} : #{@notify[key]}" }
    end
  end

  def command_part
    command = []
    @notify.each_pair do |key, value|
      command.concat(['notify', key]) if value == 'on'
    end
    return command
  end
end
$notify_handler = NotifyHandler.new

class InputHandler < Handler
  def initialize
    @syntax = {
      :root => [ -1, :input, :inputadd, :inputwhat ],
      :input => [ 1, 'input', :args ],
      :inputadd => [ 2, 'input+', :a2b, :args ],
      :inputwhat => 'input?',
      :args => [ 0, :a2b, :args ],
      :a2b => [ -1, [ :string, ':', :label ], [ :string, '=', :value ] ],
      :value => [ -1, :null, :int, :string ],
      :help => {
        :input => "Clears input mapping and passes label as name, or value of name as given directly.",
        :inputadd => "Adds to current input mapping.",
        :inputwhat => "Prints current input mapping."
      }
    }
    @order = []
    @mapping = { }
    register
  end

  def handle(parts)
    if parts[0] == 'input?'
      @order.each do |name|
        direct, val = @mapping[name]
        t = direct ? "=" : ":"
        puts "#{name} #{t} #{val}"
      end
      return
    end
    clear = parts[0] == 'input'
    order_in = []
    map_in = { }
    idx = 1
    while idx < parts.length
      name = parts[idx]
      direct = parts[idx + 1] == '='
      src = parts[idx + 2]
      idx += 3
      if map_in.has_key?(name) or not clear and @mapping.has_key?(name)
        puts "Error: #{name} already in mapping."
        return
      end
      order_in.push name
      map_in[name] = [direct, src]
    end
    if clear
      @order.clear
      @mapping.clear
    end
    @order.concat order_in
    @mapping.merge! map_in
  end

  def command_part
    command = []
    @order.each do |name|
      direct, val = @mapping[name]
      command.concat [ direct ? 'direct' : 'input', val, name ]
    end
    return command
  end
end
$input_handler = InputHandler.new

class OutputHandler < Handler
  def initialize
    @syntax = {
      :root => [ -1, :output, :outputadd, :outputwhat, :outputnaming ],
      :output => [ 1, 'output', :maps ],
      :outputadd => [ 2, 'output+', :map, :maps ],
      :outputwhat => 'output?',
      :outputnaming => [ 'output-naming', :string, :string ],
      :maps => [ 0, :map, :maps ],
      :map => [ -1, [ :string, :string ], [ :string, :null ] ],
      :help => {
        :output => "Clears output mapping and maps name to label. Using null as label discards that name.",
        :outputadd => "Adds to current output mapping.",
        :outputwhat => "Prints current output mapping.",
        :outputnaming => "Sets prefix and postfix to unmapped names."
      }
    }
    @mapping = Hash.new
    @prefix = nil
    @postfix = nil
    register
  end

  def handle(parts)
    if parts[0] == 'output?'
      puts("Prefix: #{@prefix}") unless @prefix.nil?
      puts("Postfix: #{@postfix}") unless @postfix.nil?
      @mapping.keys.sort.each do |name|
        label = @mapping[name]
        puts "\"#{name}\" \"#{label}\""
      end
      return
    end
    if parts[0] == 'output-naming'
      @prefix = parts[1].length ? parts[1] : nil
      @postfix = parts[2].length ? parts[2] : nil
      return
    end
    if parts[0] == 'output'
      @mapping.clear
      @prefix = nil
      @postfix = nil
    end
    idx = 1
    while idx < parts.length
      name = parts[idx]
      src = parts[idx + 1]
      idx += 2
      puts("#{name} : #{@mapping[name]} -> #{src}") if @mapping.has_key? name
      @mapping[name] = src
    end
  end

  def command_part
    command = []
    command.concat([ 'output-prefix', @prefix ]) unless @prefix.nil?
    command.concat([ 'output-postfix', @postfix ]) unless @postfix.nil?
    @mapping.each_pair do |name, val|
      command.concat [ 'output', name, val ]
    end
    return command
  end
end
$output_handler = OutputHandler.new

class EnvHandler < Handler
  def initialize
    @syntax = {
      :root => [ -1, :env, :envadd, :envwhat, :envclear ],
      :env => [ 1, 'env', :varvalues ],
      :envadd => [ 2, 'env+', :varval, :varvalues ],
      :envwhat => 'env?',
      :envclear => 'env-clear',
      :varvalues => [ 0, :varval, :varvalues ],
      :varval => [ :varname, :string ],
      :help => {
        :env => "Clears environment variable mapping and sets var to value.",
        :envadd => "Sets var to value in environment variable mapping.",
        :envwhat => "Prints out current mapping.",
        :envclear => "Ignores environment variables outside current mapping."
      }
    }
    @mapping = { }
    @clear = false
    register
  end

  def handle(parts)
    if parts[0] == 'env?'
      puts("Restrict environment to given values.") if @clear == true
      @mapping.keys.sort.each do |name|
        value = @mapping[name]
        puts "\"#{name}\" \"#{value}\""
      end
      return
    elsif parts[0] == 'env-clear'
      @clear = true
      return
    elsif parts[0] == 'env'
      @mapping.clear
      @clear = false
    end
    idx = 1
    while idx < parts.length
      name = parts[idx]
      value = parts[idx + 1]
      idx += 2
      puts("#{name} : #{@mapping[name]} -> #{value}") if @mapping.has_key? name
      @mapping[name] = value
    end
  end

  def command_part
    command = []
    command.push('env-clear') if @clear
    @mapping.each_pair do |name, val|
      command.concat [ 'env', name, val ]
    end
    return command
  end
end
$env_handler = EnvHandler.new

class ArgHandler < Handler
  def initialize
    @syntax = {
      :root => [ -1, :arg, :argadd, :argwhat ],
      :arg => [ 1, 'arg', :values ],
      :argadd => [ 2, 'arg+', :string, :values ],
      :argwhat => 'arg?',
      :values => [ 0, :string, :values ],
      :help => {
        :arg => "Clear argument list first and add to argument list.",
        :argadd => "Add to argument list.",
        :argwhat => "Print current program argument list."
      }
    }
    @args = []
    register
  end

  def handle(parts)
    if parts[0] == 'arg?'
      @args.each do |arg|
        puts "\"#{arg}\""
      end
      return
    end
    @args.clear if parts[0] == 'arg'
    @args.concat parts[1...parts.length]
  end

  def command_part
    return @args.clone
  end
end
$arg_handler = ArgHandler.new

class ChannelHandler < Handler
  def initialize
    @syntax = {
      :root => [ -1, :channelin, :channelout, :channelwhat ],
      :channelin => [ 'channel', 'in', :informat ],
      :channelout => [ 'channel', :outchannel, :outformat ],
      :channelwhat => 'channel?',
      :informat => [ -1, 'json', 'none' ],
      :outchannel => [ -1, 'out', 'err' ],
      :outformat => [ -1, 'json', 'bytes', 'none' ],
      :help => {
        :channelin => "Set program stdin format to JSON for data etc. input or closed if none.",
        :channelout => "Set program stdout/stderr format. Bytes is passed on as JSON array and none means to ignore any output.",
        :channelwhat => "Print current channel setting."
      }
    }
    @channels = { 'in' => 'json', 'out' => 'json', 'err' => 'bytes' }
    register
  end

  def handle(parts)
    if parts[0] == 'channel?'
      @channels.keys.sort.each do |c|
        puts "#{c} #{@channels[c]}"
      end
      return
    end
    @channels[parts[1]] = parts[2]
  end

  def command_part
    command = []
    @channels.each_pair do |c, f|
      next if f == 'none'
      direction = (c == 'in') ? 'in' : 'out'
      fmt = (f == 'json') ? 'JSON' : f
      command.concat [ direction, fmt, c ]
    end
    return command
  end
end
$channel_handler = ChannelHandler.new

$actions_run_common = %q(
---
return:
- run-finished: [ "@", run, finished ]
- run-terminated: [ "@", run, terminated ]
error:
- args-missing: [ "@", run, error, missing, "*" ]
- command-error: [ "@", run, error, identifier, in-use ]
- syntax: [ "@", run, error, "?", argument, unknown ]
- syntax: [ "@", run, error, "?", duplicate, "?" ]
- command-error: [ "@", run, error, change-directory, "?", "?" ]
- command-error: [ "@", run, error, env, argument, duplicate, "?" ]
- command-error: [ "@", run, error, env, argument, invalid, "?" ]
- command-error: [ "@", run, error, in, missing ]
- command-error: [ "@", run, error, in, multiple ]
- command-error: [ "@", run, error, notify, no-input ]
- command-error: [ "@", run, error, out, duplicate ]
- command-error: [ "@", run, error, out, missing ]
- command-error: [ "@", run, error, output, duplicate, "?" ]
- command-error: [ "@", run, error, program, "*" ]
- run-internal: [ "@", run, error, exception ]
- run-internal: [ "@", run, error, no-memory ]
- run-internal: [ "@", run, error, no-processes ]
- run-internal: [ "@", run, error, no-thread ]
- run-internal: [ "@", run, error, pipe ]
note:
- run-error-input-failed: [ "@", run, error, input, failed ]
- run-child-error-output-format: [ "@", run, error, format ]
- run-child-error-output-format: [ "@", error, format ]
- run-exit: [ "@", run, exit, "?" ]
- run-signal: [ "@", run, signal, "?" ]
- run-stop: [ "@", run, stopped, "?" ]
- run-continue: [ "@", run, continued ]
- run-closed: [ "@", run, input, closed ]
bytes:
- bytes: [ "@", run, bytes, "?", "*" ]
)

class RunHandler < Handler
  def initialize
    @syntax = {
      :root => [ 3, 'run', :identifier, :executable, 'close' ],
      :identifier => [ -1, :null, :int, :string ],
      :help => { :root => "Runs executable as identifier. If close is given, the input is closed after current input has been passed on. Uses current input, output, channel, env, and arg settings." }
    }
    print_bytes = Proc.new do |category, action, message, vars|
      out = []
      out.push(''.concat(*message[3...message.length])) if 3 < message.length
      out
    end
    @actions = PatternAction.new([ YAML.load($actions_run_common) ],
      [ print_bytes, $default_message_proc ])
    register
  end

  def handle(parts)
    id = parts[1]
    exe = parts[2]
    command = [ 'run' ]
    command.concat $notify_handler.command_part
    command.concat $input_handler.command_part
    command.concat $output_handler.command_part
    command.concat $channel_handler.command_part
    command.push('end-feed') if parts.length == 4
    command.concat $env_handler.command_part
    command.concat [ 'program', exe ]
    command.concat $arg_handler.command_part
    send(@actions, command, true)
  end
end
RunHandler.new

class PsHandler < Handler
  def initialize
    @syntax = {
      :root => 'ps',
      :help => { :root => "List running proceses." }
    }
    register
  end

  def handle(parts)
    report = " PID\t: Identifier"
    procs = $lackey_io.process
    procs.keys.sort do |id|
      report.concat "\n #{procs[id]}\t: #{id}"
    end
    puts report
  end
end
PsHandler.new

class KillHandler < Handler
  def initialize
    @syntax = {
      :root => [ 2, 'kill', :process_id, :identifiers ],
      :identifiers => [ 0, :process_id, :identifiers ],
      :help => { :root => "Terminates processes." }
    }
    @actions = PatternAction.new([{
      :note => [ { :missing => [ '@', 'terminate', 'missing', '*' ] } ]
    }], [ $default_message_proc ])
    register
  end

  def handle(parts)
    send(@actions, [ 'terminate' ].concat(parts[1...parts.length]))
  end
end
KillHandler.new

$actions_feed = %q(
---
error:
- args-missing: [ "@", feed, error, missing, "*" ]
- command-error: [ "@", feed, error, "?", argument, unknown ]
- command-error: [ "@", feed, error, "?", duplicate, "?" ]
- feed-closed: [ "@", feed, error, closed ]
- feed-process: [ "@", feed, error, not-found ]
)

class FeedHandler < Handler
  def initialize
    @syntax = {
      :root => [ 2, 'feed', :process_id, :identifiers ],
      :identifiers => [ 0, :process_id, :identifiers ],
      :help => { :root => "Pass current input set to processes." }
    }
    @actions = PatternAction.new([ YAML.load($actions_feed) ],
      [ $default_message_proc ])
    register
  end

  def handle(parts)
    c = $handler['input'].command_part
    parts[1...parts.length].each do |procid|
      command = [ 'feed', procid ]
      command.concat(c) unless c.empty? # Empty feed sends empty JSON object.
      send(@actions, command)
    end
  end
end
FeedHandler.new

class EndFeedHandler < Handler
  def initialize
    @syntax = {
      :root => [ 2, 'close', :process_id, :identifiers ],
      :identifiers => [ 0, :process_id, :identifiers ],
      :help => { :root => "Closes process input." }
    }
    notify = Proc.new do |category, action, message, vars|
      out = []
      case category
      when :note
        case action
        when :end_feed_not_open
          state = 'Closed already'
        when :end_feed_missing
          state = 'Missing'
        else
          state = nil
        end
        out.push("#{state}: #{vars.join(' ')}") unless state.nil?
      end
      out
    end
    @actions = PatternAction.new([{
      :note => [ { :end_feed_not_open => [ '@', 'end-feed', 'not-open', '*' ],
        :end_feed_missing => [ '@', 'end-feed', 'missing', '*' ] } ]
    }], [ notify, $default_message_proc ])
    register
  end

  def handle(parts)
    send(@actions, [ 'end-feed' ].concat(parts[1...parts.length]))
  end
end
EndFeedHandler.new

class RawHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'raw', :string ],
      :help => {
        :root => "Pass unchecked JSON input as single string to datalackey." }
    }
    register
  end

  def handle(parts)
    dump parts[1]
  end
end
RawHandler.new


def completer(str)
  # See if we can get the command that is being typed.
  begin
    full = Readline.line_buffer.clone
  rescue NotImplementedError
    # No context available so just pick matching words.
    cands = $handler.keys.grep(/^#{Regexp.escape(str)}/)
    cands.concat $lackey_io.data.keys.grep(/^#{Regexp.escape(str)}/)
    cands.concat $lackey_io.process.keys.grep(/^#{Regexp.escape(str)}/)
    # Should add various words from syntax. Basically scan for strings.
    cands.sort!
    return cands
  end
  begin
    parts = Shellwords.shellsplit(full)
  rescue ArgumentError
    begin
      parts = Shellwords.shellsplit(full + '"')
    rescue ArgumentError
      parts = Shellwords.shellsplit(full + "'")
    end
  end
  if parts.length < 2 and not full.end_with? ' '
    return $handler.keys.sort.grep(/^#{Regexp.escape(str)}/)
  end
  h = $handler[parts[0]]
  return (h.nil? ? [] : h.completion_candidates(parts, str))
end
Readline.completion_proc = Proc.new { |str| completer(str) }


# Load history.
history_dir = arguments.directory.nil? ? Dir.pwd : arguments.directory
history_file = File.join(history_dir, history_file_basename)
if File.exist? history_file
  begin
    fp = File.new history_file
    fp.readlines.each { |line| Readline::HISTORY << line.chomp  }
  rescue StandardError
    STDERR.puts "Failed to read history file: #{history_file}"
  end
end

while not $exiting and line = Readline.readline($prompt, false)
  line.strip!
  begin
    parts = line.shellsplit
  rescue ArgumentError => e
    puts e.to_s
    next
  end
  next if parts.length == 0
  h = $handler[parts[0]]
  if h.nil?
    puts "Unknown command: #{parts[0]}"
    next
  end
  if $stdin.tty? and (Readline::HISTORY.length == 0 or Readline::HISTORY[Readline::HISTORY.length - 1] != line)
    Readline::HISTORY.push line
  end
  if h.verify(parts)
    h.handle(parts)
  else
    puts "Command verify failed."
  end
end

# For recall to work, ensure there is exit in case ctrl-D was pressed.
if Readline::HISTORY.length == 0 or not Readline::HISTORY[Readline::HISTORY.length - 1].start_with? 'exit'
  Readline::HISTORY.push 'exit'
end

# Save history.
if $stdin.tty?
  begin
    fp = Pathname.new history_file
    fp.open('w') do |f|
      Readline::HISTORY.to_a.last(history_file_max_lines).each { |l| f.puts l }
    end
  rescue StandardError
    STDERR.puts "Failed to write history file: #{history_file}"
  end
end

$lackey.finish
$lackey_io.close
stderr_discarder.close
$lackey_io.finish
$presenter.finish
puts() unless $exiting
puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit $exit_handler.code
