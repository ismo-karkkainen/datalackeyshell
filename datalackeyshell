#!/usr/bin/ruby

require 'optparse'
require 'readline'
require 'shellwords'
require 'open3'

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
  end

  def parse(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyshell [options]"
      opts.separator ""
      opts.separator "Options:"
      opts.on("-m", "--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("-d", "--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit
      end
      opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("-p", "--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
    end
    parser.parse!(args)
    # Perform sanity checks on the values.
    if @memory and not (@directory.nil? and @permissions.nil?)
      puts "Cannot use both --memory and --directory or --permissions."
      exit
    end
    if not @memory
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      @permissions = "600" if @permissions == nil
    end
  end
end

arguments = Arguments.new
arguments.parse(ARGV)

exe = arguments.lackey
if exe == nil
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  for k in 0 ... dirs.length
    exe = File.join(dirs[k], "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  puts("datalackey not found.") if exe == nil
else
  if not File.exist?(exe) or not File.executable?(exe)
    puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe == nil

class LackeyProcess
  attr_reader :exit_code

  def initialize(exe, directory, permissions, memory)
    @accum_stdout = []
    @accum_stderr = []
    args = [ exe,
        '--command-in', 'stdin', 'JSON', '--command-out', 'stdout', 'JSON' ]
    args.push('--memory') if memory
    args.concat([ '--directory', directory ]) if directory != nil
    args.concat([ '--permissions', permissions ]) if not memory
    @stdin, @stdout, @stderr, @wait_thread = Open3.popen3(*args)
    @read_stdout = Thread.new do
      until (raw = @stdout.gets(nil)).nil? do
        @accum_stdout.push(raw)
        # Must accumulate full lines to get JSON objects.
      end
      @stdout.close
    end
    @read_stderr = Thread.new do
      until (raw = @stderr.gets(nil)).nil? do
        @accum_stderr.push(raw)
        # This should not happen unless there is an internal error of sorts.
      end
      @stderr.close
    end
  end

  def relay(message)
    @stdin.puts message
    @stdin.flush
  end

  def finish
    @stdin.close
    @wait_thread.join
    @exit_code = @wait_thread.value.exitstatus
  end

  def wait_output
    @read_stdout.join
    @read_stderr.join
  end
end

$lackey = LackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)
# Datalackey class that deals with running it and allowing I/O.
# Store error output and normal output until something reads it.
# Allow input to be sent and do it as is.

# Presumably the shell object will deal with identifiers.
# Maybe have a translator object that deals with forming messages and
# splitting the output into whatever it is. Errors and notifications.

# Declare command handler classes here as well as the mapping.
$handler = Hash.new
$exiting = false

class Handler
  def initialize(usage_text, help_text)
    @help_text = help_text
    @usage_text = usage_text
  end

  def help
    puts "#{@usage_text} : #{@help_text}"
  end

  def usage
    puts "Usage: #{@usage_text}"
  end
end

class HelpHandler < Handler
  def initialize
    super('help', "Print command help.")
  end

  def handle(parts)
    $handler.keys.sort.each do |key|
      $handler[key].help
    end
  end
end

$handler['help'] = HelpHandler.new

class ExitHandler < Handler
  attr_reader :code

  def initialize
    super("exit [code]", "Waits for datalackey to finish, exits with code.")
    @code = 0
  end

  def handle(parts)
    $exiting = true
    return if parts.length == 1
    if parts.length != 2
      usage
      $exiting = false
      return
    end
    begin
      @code = Integer(parts[1])
    rescue ArgumentError
      usage
      $exiting = false
    end
  end
end

$handler['exit'] = ExitHandler.new

while line = Readline.readline("> ", true)
  parts = line.shellsplit
  next if parts.length == 0
  if $handler.has_key? parts[0]
    $handler[parts[0]].handle(parts)
  else
    puts "Unknown command: #{parts[0]}"
  end
  break if $exiting

  # Parse line into shell commands.
  # Trim input and split, but should respect quotes and escaping.
  # Allow separation of commands using semicolon?

  # datalackey direct commands:
  # {} (set label=value ...)
  # Get (cat label ...)
  # Rename (mv label new)
  # Delete (rm label)
  # List (ls [pattern])
  # Run (run) See below for all parts.
  # Processes (ps)
  # Terminate (kill identifier)
  # Feed (feed identifier [name=]label|direct name=value ...)
  # EndFeed (eof identifier)
  # StorageInfo (du) ?
  # Version (version) Prints this and datalackey versions.
  # NoOperation (ping) ?
  # Other commands for convenience with above:
  # echo on|off|last Print the command sent to datalackey always|never|last.
  # Run helper commands.
  # input name=label|direct name=value ... Construct/clear input mapping.
  # input+ name=label|direct name=value ... Append to input mapping.
  # output label=name ... Construct/clear output mapping.
  # output+ label=name ... Append to output mapping.
  # format in|out json When there is an alternative.
  # channel in|out pipe|shared_memory When there is an alternative.
  # env var=value ... Contruct/clear environment.
  # env+ var=value ... Append to environment.
  # args arguments as they are... Construct/clear program argument list.
  # args+ arguments as they are... Append to program argument list.
  # run program [eof] Run using input, output, format, channel, env, args.
  #  Optional eof indicates to close feed in the same call.
  # print input, output, format, channel, env, args Print argument state or
  #  without arguments print them all.
  # recall program input output format channel env args Fetches value from
  #  last run of program, without argumets fetches all.
  # re-run program ... Like "recall program ..." and "run program" so uses
  #  current for parts that have not been recalled.
  #  recall allows for editing values, re-run direct re-use
  # history [pattern] Shows history matching the pattern.
end

$lackey.finish
$lackey.wait_output
# Print out the remaining output here.
puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit $handler['exit'].code
