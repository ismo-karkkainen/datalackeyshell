#!/usr/bin/env ruby

# Argument handling and checking
# datalackey process
# Presenting command output
# Notification presenters
# Command handlers
# Run command handlers

require 'optparse'
require 'readline'
require 'shellwords'
require 'open3'
require 'json'
require 'yaml'
require 'set'
require 'pathname'
require 'io/console'

$version = 1
history_file_basename = '.datalackeyshell.history'
history_file_max_lines = 2000

# Argument handling and checking

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
  end

  def parse(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyshell [options]"
      opts.separator ""
      opts.separator "Options:"
      opts.on("-m", "--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("-d", "--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit 0
      end
      opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("-p", "--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
    end
    parser.parse!(args)
    # Perform sanity checks on the values.
    if @memory and not (@directory.nil? and @permissions.nil?)
      STDERR.puts "Cannot use both --memory and --directory or --permissions."
      exit 1
    end
    if not @memory
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        STDERR.puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      @permissions = "600" if @permissions.nil?
    end
  end
end

arguments = Arguments.new
arguments.parse(ARGV)

exe = arguments.lackey
if exe == nil
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  for k in 0 ... dirs.length
    exe = File.join(dirs[k], "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  puts("datalackey not found.") if exe == nil
else
  if not File.exist?(exe) or not File.executable?(exe)
    STDERR.puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe == nil

# datalackey process

require './datalackey-lib.rb'

$lackey = DatalackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)
stderr_discarder = DiscardReader.new($lackey.stderr)
$lackey_io = DatalackeyIO.new($lackey.stdin, $lackey.stdout)

# Presenting command output

def indent_puts(long)
  rows, cols = IO.console.winsize
  if long.length < cols
    puts long
    return
  end
  pieces = long.split
  line = pieces.first
  k = 1
  while k < pieces.length
    if line.length + 1 + pieces[k].length <= cols
      line << ' ' << pieces[k]
    else
      puts line
      line = '  ' + pieces[k]
    end
    k += 1
  end
  puts line
end

$prompt = '> '
def reprompt
  return unless $stdin.tty?
  print $prompt
  $stdout.flush
  Readline.redisplay
end

def prompt_print(message)
  puts() if $stdin.tty?
  indent_puts message
  reprompt
end

class OutputPresenter
  attr_accessor :echo

  def initialize(initial_echo = false)
    @echo = initial_echo
    @present_output = Thread.new do
      until $lackey_io.closed?
        msgs = $lackey_io.get_messages
        if msgs.empty?
          sleep(0.1)
          next
        end
        puts
        msgs.each do |out|
          puts(out.message) if @echo
          puts "#{out.category} / #{out.action} : #{out.message.join(' ')}"
        end
        reprompt
      end
    end
  end

  def finish
    @present_output.join
  end
end
$presenter = OutputPresenter.new

# Command handlers

$handler = Hash.new(nil)
$exiting = false
$command_echo = false

class Handler

  def construct_usages(result, value, seen = [])
    if value.is_a? Array
      prev = nil
      result.push('[') if value.include?(nil)
      value.each do |alt|
        next if alt.nil?
        if prev.is_a? String
          result.push ' '
        elsif prev.is_a? Symbol
          result.push(' ') unless result.last == '[' or result.last == '|'
        elsif prev.is_a? Array
          result.push '|'
        end
        prev = alt
        construct_usages(result, alt, seen)
      end
      result.pop() if result.last == '|'
      result.push(']') if value.include?(nil)
      return result
    end
    if seen.include? value
      result.push '...'
      return result
    end
    if @syntax.has_key? value
      seen.push value
      construct_usages(result, @syntax[value], seen)
      seen.pop
      return result
    end
    result.push value.to_s
    return result
  end

  def usages
    top = @syntax[:root]
    return { :root => [ top ] } if top.is_a? String # Parameterless command.
    raise ArgumentError.new('Not String or Array.') unless top.is_a? Array
    results = { }
    if top.first.is_a? String # Command with parameters.
      results[:root] = construct_usages([], :root)
    else # Command with variations. Expect array of arrays of symbol(s).
      top.each { |sym| results[sym.first] = construct_usages([], sym) }
    end
    return results
  end

  def print_help
    msgs = []
    usages.each_pair do |key, value|
      m = "#{value.join}"
      m.concat(" : #{@syntax[:help][key]}") if @syntax[:help].include? key
      msgs.push m
    end
    msgs.sort.each { |m| indent_puts m }
  end

  def completion_search(suggestions, parts, part_idx, key, item)
    return true if part_idx >= parts.length
    return false if item.nil?
    last = part_idx + 1 == parts.length
    if item.is_a? Symbol # These either validate part or add suggestions.
      cands = nil
      case item
      when :command
        cands = $handler.keys
      when :label
        cands = $lackey_io.data.keys
      when :process_id
        cands = $lackey_io.process.keys
      when :history_process_id
        cands = [] # Run command identifiers from history.
        scan_history([ Regexp.new('^run[[:blank:]]+') ]).each do |h|
          pieces = h.shellsplit
          cands.push(pieces[1]) if pieces.length >= 2
        end
      when :executable
        return File.executable?(parts[part_idx]) unless last
        cands = Dir[parts.last + '*'].grep(/^#{Regexp.escape(parts.last)}/)
      when :string
        return true # Anything goes.
      when :int
        begin
          Integer(parts[part_idx])
          return true # Any integer is fine.
        rescue ArgumentError
          return false
        end
      when :null
        # Requires that :null is before :string in allowed values.
        return $handler['null'].null == parts[part_idx] unless last
        cands = [ $handler['null'].null ]
      when :varname
        return parts[part_idx].include?('=') unless last
        cands = []
      else
        return completion_search(suggestions, parts, part_idx, item, @syntax[item])
      end
      return false if cands.nil?
      # There is a slight chance that something changes while user is typing.
      # Hence this may pass at some point and then fail.
      return cands.include?(parts[part_idx]) unless last
      suggestions.concat cands
      return true
    elsif item.is_a? String
      return item == parts[part_idx] unless last
      suggestions.push item
      return true
    elsif item.is_a? Array
      ok = true
      item.each do |sub|
        ok = completion_search(suggestions, parts, part_idx, key, sub)
        break unless ok
        part_idx = part_idx + 1 unless sub.is_a? Array
      end
      return ok
    end
    raise ArgumentError.new('Item other than nil, Symbol, String or Array.')
  end

  def completion_candidates(parts, str)
    suggestions = []
    parts.push('') if str.empty?
    completion_search(suggestions, parts, 0, :root, @syntax[:root])
    return suggestions.grep(/^#{Regexp.escape(str)}/).sort.uniq
  end

  def verify(parts)
    # Do like completion_search but require exact matches.
    return true
  end

  def send(patt_act, message, user_id = false)
    $lackey_io.send(patt_act, message, user_id, $command_echo ? $stdout : nil)
  end

  def dump(json_as_string)
    $lackey_io.dump(json_as_string, $command_echo ? $stdout : nil)
  end

  def present_other(parsed, json)
    start = parsed[2] == '' ? 3 : 2
    prompt_print(parsed[start...parsed.length].join("\n")) if parsed.length > 3
  end

  def present(parsed, json)
    return if parsed.length < 3
    present_other(parsed, json)
  end
end

class HelpHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'help', :cmds ],
      :cmds => [ [ :command, :cmds ], nil ],
      :help => { :root => "Print command help." }
    }
  end

  def handle(parts)
    printed = Set.new
    keys = (parts.length > 1) ? parts[1...parts.length] : $handler.keys
    keys.sort.each do |key|
      if $handler.include? key
        object = $handler[key]
        next if printed.include? object
        printed.add object
        object.print_help
      else
        puts "Unknown command: #{key}"
      end
    end
  end
end
$handler['help'] = HelpHandler.new
$handler['usage'] = $handler['help']

class ExitHandler < Handler
  attr_reader :code

  def initialize
    @syntax = {
      :root => [ 'exit', :param ],
      :param => [ [ :int ], nil ],
      :help => { :root => "Waits for datalackey to finish, exits with code." }
    }
    @code = 0
  end

  def handle(parts)
    $exiting = true
    @code = Integer(parts[1]) if parts.length == 2
  end
end
$handler['exit'] = ExitHandler.new

class NullHandler < Handler
  attr_reader :null

  def initialize
    @syntax = {
      :root => [ [ :nullcmd ], [ :nullcmdwhat ] ],
      :nullcmd => [ 'null', :string ],
      :nullcmdwhat => 'null?',
      :help => {
        :nullcmd => "Sets string that is interpreted as null when null is allowed.",
        :nullcmdwhat => "Prints out string that is interpreted as null."
      }
    }
    @null = 'null'
  end

  def handle(parts)
    if parts.length == 2
      @null = parts.last
    else
      puts "String interpreted as null is: '#{@null}'"
    end
  end
end
$handler['null'] = NullHandler.new
$handler['null?'] = $handler['null']

class ListHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'ls', :regexps ],
      :regexps => [ [ :string, :regexps ], nil ],
      :help => { :root => "Prints out the list of data labels that match optional regular expressions." }
    }
  end

  def handle(parts)
    exps = []
    clean = parts[1...parts.length].sort.uniq
    clean.each { |e| exps.push Regexp.new(e) }
    $lackey_io.data.keys.sort.each do |label|
      match = exps.length == 0
      exps.each do |e|
        match = e.match(label)
        break if match
      end
      puts(label) if match
    end
  end
end
$handler['ls'] = ListHandler.new

class SetHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'set', :string, :string ],
      :help => { :root => "Sets label to JSON-encoded value (in single quotes as needed)." }
    }
  end

  def handle(parts)
    v = parts[2...parts.length].join("")
    dump "{\"#{parts[1]}\":#{v}}"
  end
end
$handler['set'] = SetHandler.new

class GetHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'get', :label, :labels ],
      :labels => [ [ :label, :labels ], nil ],
      :help => { :root => "Gets labels." }
    }
    @actions = PatternAction.new([{
      :return => [ { :get => [ '@', 'get', '', '?' ] } ],
      :error => [ { :get_fail => [ '@', 'get', 'failed', '*' ] } ]
    }])
  end

  def handle(parts)
    send(@actions, [ 'get' ].concat(parts[1...parts.length]))
  end

  def present_other(parsed, json)
    return if parsed[2] != ''
    head = "[#{parsed[0]},\"#{parsed[1]}\",\"\","
    prompt_print json[head.length...json.length - 1]
  end
end
$handler['get'] = GetHandler.new

class RenameHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'mv', :label_pair, :label_pairs ],
      :label_pairs => [ [ :label_pair, :label_pairs ], nil ],
      :label_pair => [ :label, :string ],
      :help => { :root => "Re-labels values. Takes label and new name pairs." }
    }
    @actions = PatternAction.new([{
      :notify => [ { :missing => [ '@', 'rename', 'missing', '*' ] } ]
    }])
  end

  def handle(parts)
    send(@actions, [ 'rename' ].concat(parts[1...parts.length]))
  end
end
$handler['mv'] = RenameHandler.new

class DeleteHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'rm', :label, :labels ],
      :labels => [ [ :label, :labels ], nil ],
      :help => { :root => "Removes labels from storage." }
    }
    @actions = PatternAction.new([{
      :notify => [ { :missing => [ '@', 'delete', 'missing', '*' ] } ]
    }])
  end

  def handle(parts)
    send(@actions, [ 'delete' ].concat(parts[1...parts.length]))
  end
end
$handler['rm'] = DeleteHandler.new

class StorageInfoHandler < Handler
  def initialize
    @syntax = {
      :root => 'info',
      :help => { :root => "Print information about storage." }
    }
    @actions = PatternAction.new([{
      :return => [ { 'storage-info' => [ '@', 'storage-info', '', '?' ] } ]
    }])
  end

  def handle(parts)
    send(@actions, [ 'storage-info' ])
  end

  def present_other(parsed, json)
    return if parsed[2] != '' or parsed.length != 4
    puts
    parsed[3].keys.sort.each do |label|
      info = parsed[3][label]
      description = "#{label} : "
      sep = ''
      info.keys.sort.each do |format|
        description.concat "#{sep}#{format}: #{info[format]}"
        sep = ', '
      end
      puts description
    end
    reprompt
  end
end
$handler['info'] = StorageInfoHandler.new

class PingHandler < Handler
  def initialize
    @syntax = {
      :root => 'ping',
      :help => { :root => "Check that datalackey responds." }
    }
    @actions = PatternAction.new([])
  end

  def handle(parts)
    send(@actions, [ 'no-op' ])
  end

  def present_other(parsed, json)
    prompt_print "Datalackey responded."
  end
end
$handler['ping'] = PingHandler.new

class VersionHandler < Handler
  def initialize
    @syntax = {
      :root => 'version',
      :help => { :root => "Print version information." }
    }
  end

  def handle(parts)
    description = "shell: #{$version}"
    v = $lackey_io.version
    v.keys.sort.each { |key| description.concat "\n#{key}: #{v[key]}" }
    prompt_print description
  end
end
$handler['version'] = VersionHandler.new

class EchoHandler < Handler
  def initialize
    @syntax = {
      :root => [ [ :lackey ], [ :lackeywhat ] ],
      :lackey => [ 'lackey', :inout, :onoff ],
      :lackeywhat => 'lackey?',
      :inout => [ [ 'command' ], [ 'reply' ] ],
      :onoff => [ [ 'on' ], [ 'off' ] ],
      :help => {
        :lackey => "Set the printing of datalackey commands/replies on/off.",
        :lackeywhat => "Print datalakcey command/reply printing status."
      }
    }
  end

  def handle(parts)
    if parts.length > 1
      $command_echo = parts[2] == 'on' if parts[1] == 'command'
      $presenter.echo = parts[2] == 'on' if parts[1] == 'reply'
    else
      puts "command: #{$command_echo ? 'on' : 'off'}"
      puts "reply  : #{$presenter.echo ? 'on' : 'off'}"
    end
  end
end
$handler['lackey'] = EchoHandler.new

class NotifyHandler < Handler
  def initialize
    @syntax = {
      :root => [ [ :notify ], [ :notifywhat ] ],
      :notify => [ 'notify', :procdata, :onoff ],
      :notifywhat => 'notify?',
      :procdata => [ [ 'data' ], [ 'process' ] ],
      :onoff => [ [ 'on' ], [ 'off' ] ],
      :help => {
        :notify => "Turn process or data notifications on or off.",
        :notifywhat => "Print data/process notification status."
      }
    }
    @notify = { 'process' => 'off', 'data' => 'on' }
  end

  def handle(parts)
    if parts.length > 1
      @notify[parts[1]] = parts[2]
    else
      @notify.keys.sort.each { |key| puts "#{key} : #{@notify[key]}" }
    end
  end

  def present(parsed, json)
    prompt_print "#{parsed[1].capitalize} #{parsed[2]} : #{parsed[3]}"
  end
end
$handler['notify'] = NotifyHandler.new

def scan_history(regexps)
  matched = Array.new
  Readline::HISTORY.take(Readline::HISTORY.length - 1).each do |h|
    match = regexps.length == 0
    regexps.each do |e|
      match = e.match(h)
      break if match
    end
    matched.push(h) if match
  end
  return matched
end

class HistoryHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'history', :regexps ],
      :regexps => [ [ :string, :regexps ], nil ],
      :help => { :root => "Print commands that match any regex, or all." }
    }
  end

  def handle(parts)
    exps = []
    parts[1...parts.length].each { |e| exps.push Regexp.new(e) }
    scan_history(exps).each { |h| puts h }
  end
end
$handler['history'] = HistoryHandler.new

class RecallHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'recall', :history_process_id ],
      :help => { :root => "Fetch last \"run identifier\" related settings from history. Finds the input, output, env, arg, and channel settings that were in effect when last run with given identifier was done. If no identifier is given, last run command identifier is used. Prints the lines found from history." }
    }
  end

  def scan_until_first(new_to_old, exps)
    regexps = []
    exps.each { |e| regexps.push Regexp.new(e) }
    matches = []
    new_to_old.each do |c|
      for k in 0...regexps.length
        next unless regexps[k].match(c)
        matches.push(c)
        return matches if k == 0
        break
      end
    end
    return matches
  end

  def print_until_first(new_to_old, exps)
    n2o = scan_until_first(new_to_old, exps)
    while not n2o.empty?
      puts n2o.pop
    end
  end

  def handle(parts)
    id_given = parts.length == 2
    es = [ '^input[+]?[[:blank:]]+', '^output[+]?[[:blank:]]+',
      '^arg[+]?[[:blank:]]+', '^env[+]?[[:blank:]]+', '^env-clear$',
      '^channel[[:blank:]]+', '^exit' ]
    es.push('^run[[:blank:]]+' + (id_given ? parts[1] + '[[:blank:]]+' : ''))
    exps = Array.new
    es.each { |e| exps.push Regexp.new(e) }
    candidates = scan_history(exps)
    # Drop everything after the last matching run command.
    while not candidates.empty? and not candidates.last.start_with? 'run'
      candidates.pop
    end
    # Pick commands before last exit. Reverses order.
    session = Array.new
    while not candidates.empty? and not candidates.last.start_with? 'exit'
      session.push candidates.pop
    end
    print_until_first(session, [ '^channel[[:blank:]]+in[[:blank:]]' ])
    print_until_first(session, [ '^channel[[:blank:]]+out[[:blank:]]' ])
    print_until_first(session, [ '^channel[[:blank:]]+err[[:blank:]]' ])
    print_until_first(session, [ '^env[[:blank:]]', '^env[+][[:blank:]]', '^env-clear$' ])
    print_until_first(session, [ '^arg[[:blank:]]', '^arg[+][[:blank:]]' ])
    print_until_first(session, [ '^input[[:blank:]]', '^input[+][[:blank:]]' ])
    print_until_first(session, [ '^output[[:blank:]]', '^output[+][[:blank:]]', '^output-naming[[:blank:]]' ])
  end
end
$handler['recall'] = RecallHandler.new

# Run command handlers

class InputHandler < Handler
  def initialize
    @syntax = {
      :root => [ [ :input ], [ :inputadd ], [ :inputwhat ] ],
      :input => [ 'input', :args ],
      :inputadd => [ 'input+', :a2b, :args ],
      :inputwhat => 'input?',
      :args => [ [ :a2b, :args ], nil ],
      :a2b => [ [ :string, ':', :label ], [ :string, '=', :value ] ],
      :value => [ [ :null ], [ :int ], [ :string ] ],
      :help => {
        :input => "Clears input mapping and passes label as name, or value of name as given directly. Allowed values are integers and strings. Quote '\"string value\"'.",
        :inputadd => "Adds to current input mapping.",
        :inputwhat => "Prints current input mapping."
      }
    }
    @order = []
    @mapping = { }
  end

  def handle(parts)
    if parts[0] == 'input?'
      @order.each do |name|
        direct, val = @mapping[name]
        t = direct ? "=" : ":"
        puts "#{name} #{t} #{val}"
      end
      return
    end
    clear = parts[0] == 'input'
    order_in = []
    map_in = { }
    idx = 1
    while idx < parts.length
      name = parts[idx]
      direct = parts[idx + 1] == '='
      src = parts[idx + 2]
      idx += 3
      if map_in.has_key?(name) or not clear and @mapping.has_key?(name)
        puts "Error: #{name} already in mapping."
        return
      end
      if direct
        begin
          check = JSON.load(src)
        rescue JSON::ParserError
          puts "Error: #{name} value is invalid: #{src}"
          return
        end
      end
      order_in.push name
      map_in[name] = [direct, src]
    end
    if clear
      @order.clear
      @mapping.clear
    end
    @order.concat order_in
    @mapping.merge! map_in
  end

  def command_part
    command = []
    @order.each do |name|
      direct, val = @mapping[name]
      command.concat [ direct ? 'direct' : 'input', val, name ]
    end
    return command
  end
end
$handler['input'] = InputHandler.new
$handler['input+'] = $handler['input']
$handler['input?'] = $handler['input']

class OutputHandler < Handler
  def initialize
    @syntax = {
      :root => [ [ :output ], [ :outputadd ], [ :outputwhat ], [ :outputnaming ] ],
      :output => [ 'output', :maps ],
      :outputadd => [ 'output+', :map, :maps ],
      :outputwhat => 'output?',
      :outputnaming => [ 'output-naming', :string, :string ],
      :maps => [ [ :map, :maps ], nil ],
      :map => [ [ :string, :string ], [ :string, :null ] ],
      :help => {
        :output => "Clears output mapping and maps name to label. Using null as label discards that name.",
        :outputadd => "Adds to current output mapping.",
        :outputwhat => "Prints current output mapping.",
        :outputnaming => "Sets prefix and postfix to unmapped names."
      }
    }
    @mapping = Hash.new
    @prefix = nil
    @postfix = nil
  end

  def handle(parts)
    if parts[0] == 'output?'
      puts("Prefix: #{@prefix}") unless @prefix.nil?
      puts("Postfix: #{@postfix}") unless @postfix.nil?
      @mapping.keys.sort.each do |name|
        label = @mapping[name]
        puts "\"#{name}\" \"#{label}\""
      end
      return
    end
    if parts[0] == 'output-naming'
      @prefix = parts[1].length ? parts[1] : nil
      @postfix = parts[2].length ? parts[2] : nil
      return
    end
    if parts[0] == 'output'
      @mapping.clear
      @prefix = nil
      @postfix = nil
    end
    idx = 1
    while idx < parts.length
      name = parts[idx]
      src = parts[idx + 1]
      idx += 2
      puts("#{name} : #{@mapping[name]} -> #{src}") if @mapping.has_key? name
      @mapping[name] = src
    end
  end

  def command_part
    command = []
    command.concat([ 'output-prefix', @prefix ]) unless @prefix.nil?
    command.concat([ 'output-postfix', @postfix ]) unless @postfix.nil?
    @mapping.each_pair do |name, val|
      command.concat [ 'output', name, val ]
    end
    return command
  end
end
$handler['output'] = OutputHandler.new
$handler['output+'] = $handler['output']
$handler['output-naming'] = $handler['output']
$handler['output?'] = $handler['output']

class EnvHandler < Handler
  def initialize
    @syntax = {
      :root => [ [ :env ], [ :envadd ], [ :envwhat ], [ :envclear ] ],
      :env => [ 'env', :varvalues ],
      :envadd => [ 'env+', :varval, :varvalues ],
      :envwhat => 'env?',
      :envclear => 'env-clear',
      :varvalues => [ [ :varval, :varvalues ], nil ],
      :varval => [ :varname, :value ],
      :value => [ [ :int ], [ :string ] ],
      :help => {
        :env => "Clears environment variable mapping and sets var to value.",
        :envadd => "Sets var to value in environment variable mapping.",
        :envwhat => "Prints out current mapping.",
        :envclear => "Ignores environment variables outside current mapping."
      }
    }
    @mapping = { }
    @clear = false
  end

  def handle(parts)
    if parts[0] == 'env?'
      puts("Restrict environment to given values.") if @clear == true
      @mapping.keys.sort.each do |name|
        value = @mapping[name]
        puts "\"#{name}\" \"#{value}\""
      end
      return
    elsif parts[0] == 'env-clear'
      @clear = true
      return
    elsif parts[0] == 'env'
      @mapping.clear
      @clear = false
    end
    idx = 1
    while idx < parts.length
      name = parts[idx]
      value = parts[idx + 1]
      idx += 2
      puts("#{name} : #{@mapping[name]} -> #{value}") if @mapping.has_key? name
      @mapping[name] = value
    end
  end

  def command_part
    command = []
    command.push('env-clear') if @clear
    @mapping.each_pair do |name, val|
      command.concat [ 'env', name, val ]
    end
    return command
  end
end
$handler['env'] = EnvHandler.new
$handler['env+'] = $handler['env']
$handler['env-clear'] = $handler['env']
$handler['env?'] = $handler['env']

class ArgHandler < Handler
  def initialize
    @syntax = {
      :root => [ [ :arg ], [ :argadd ], [ :argwhat ] ],
      :arg => [ 'arg', :values ],
      :argadd => [ 'arg+', :value, :values ],
      :argwhat => 'arg?',
      :values => [ [ :value, :values ], nil ],
      :value => [ [ :int ], [ :string ] ],
      :help => {
        :arg => "Clear argument list first and add to argument list.",
        :argadd => "Add to argument list.",
        :argwhat => "Print current program argument list."
      }
    }
    @args = Array.new
  end

  def handle(parts)
    if parts[0] == 'arg?'
      @args.each do |arg|
        puts "\"#{arg}\""
      end
      return
    end
    @args.clear if parts[0] == 'arg'
    @args.concat parts[1...parts.length]
  end

  def command_part
    return @args.clone
  end
end
$handler['arg'] = ArgHandler.new
$handler['arg+'] = $handler['arg']
$handler['arg?'] = $handler['arg']

class ChannelHandler < Handler
  def initialize
    @syntax = {
      :root => [ [ :channelin ], [ :channelout ], [ :channelwhat ] ],
      :channelin => [ 'channel', 'in', :informat ],
      :channelout => [ 'channel', :outchannel, :outformat ],
      :channelwhat => 'channel?',
      :informat => [ [ 'json' ], [ 'none' ] ],
      :outchannel => [ [ 'out' ], [ 'err' ] ],
      :outformat => [ [ 'json' ], [ 'bytes' ], [ 'none' ] ],
      :help => {
        :channelin => "Set program stdin format to JSON for data etc. input or closed if none.",
        :channelout => "Set program stdout/stderr format. Bytes is passed on as JSON array and none means to ignore any output.",
        :channelwhat => "Print current channel setting."
      }
    }
    @channels = { 'in' => 'json', 'out' => 'json', 'err' => 'bytes' }
  end

  def handle(parts)
    if parts[0] == 'channel?'
      @channels.keys.sort.each do |c|
        puts "#{c} #{@channels[c]}"
      end
      return
    end
    @channels[parts[1]] = parts[2]
  end

  def command_part
    command = []
    @channels.each_pair do |c, f|
      next if f == 'none'
      direction = (c == 'in') ? 'in' : 'out'
      fmt = (f == 'json') ? 'JSON' : f
      command.concat [ direction, fmt, c ]
    end
    return command
  end
end
$handler['channel'] = ChannelHandler.new
$handler['channel?'] = $handler['channel']

$actions_run_common = %q(
---
return:
- run-finished: [ "@", run, finished ]
- run-terminated: [ "@", run, terminated ]
error:
- args-missing: [ "@", run, error, missing, "*" ]
- command-error: [ "@", run, error, identifier, in-use ]
- syntax: [ "@", run, error, "?", argument, unknown ]
- syntax: [ "@", run, error, "?", duplicate, "?" ]
- command-error: [ "@", run, error, change-directory, "?", "?" ]
- command-error: [ "@", run, error, env, argument, duplicate, "?" ]
- command-error: [ "@", run, error, env, argument, invalid, "?" ]
- command-error: [ "@", run, error, in, missing ]
- command-error: [ "@", run, error, in, multiple ]
- command-error: [ "@", run, error, notify, no-input ]
- command-error: [ "@", run, error, out, duplicate ]
- command-error: [ "@", run, error, out, missing ]
- command-error: [ "@", run, error, output, duplicate, "?" ]
- command-error: [ "@", run, error, program, "*" ]
- run-internal: [ "@", run, error, exception ]
- run-internal: [ "@", run, error, no-memory ]
- run-internal: [ "@", run, error, no-processes ]
- run-internal: [ "@", run, error, no-thread ]
- run-internal: [ "@", run, error, pipe ]
notify:
- run-error-input-failed: [ "@", run, error, input, failed ]
- run-child-error-output-format: [ "@", run, error, format ]
- run-child-error-output-format: [ "@", error, format ]
- run-exit: [ "@", run, exit, "?" ]
- run-signal: [ "@", run, signal, "?" ]
- run-stop: [ "@", run, stopped, "?" ]
- run-continue: [ "@", run, continued ]
- run-closed: [ "@", run, input, closed ]
)

class RunHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'run', :identifier, :executable, :close ],
      :identifier => [ [ :null ], [ :int ], [ :string ] ],
      :close => [ [ 'close' ], nil ],
      :help => { :root => "Runs executable as identifier. If close is given, the input is closed after current input has been passed on. Uses current input, output, channel, env, and arg settings." }
    }
    @actions = PatternAction.new([ YAML.load($actions_run_common) ])
  end

  def handle(parts)
    id = parts[1]
    exe = parts[2]
    command = [ 'run' ]
    c = $handler['input'].command_part
    command.concat(c) unless c.empty?
    c = $handler['output'].command_part
    command.concat(c) unless c.empty?
    c = $handler['channel'].command_part
    command.concat(c) unless c.empty?
    command.push('end-feed') if parts.length == 4
    c = $handler['env'].command_part
    command.concat(c) unless c.empty?
    command.concat [ 'program', exe ]
    c = $handler['arg'].command_part
    command.concat(c) unless c.empty?
    send(@actions, command, true)
  end

  def present_other(parsed, json)
    if parsed[2] == 'bytes'
      # Turn into string using the number values and print.
      msg = ''
      parsed[3...parsed.length].each do |v|
        msg.concat v.chr
      end
      prompt_print "#{parsed[0]} bytes output:\n#{msg}"
    else
      msg = parsed[2...parsed.length].join(' ')
      prompt_print "#{parsed[0]} : #{msg}"
    end
  end
end
$handler['run'] = RunHandler.new

class PsHandler < Handler
  def initialize
    @syntax = {
      :root => 'ps',
      :help => { :root => "List running proceses." }
    }
  end

  def handle(parts)
    report = " PID\t: Identifier"
    procs = $lackey_io.process
    procs.keys.sort do |id|
      report.concat "\n #{procs[id]}\t: #{id}"
    end
    puts report
  end
end
$handler['ps'] = PsHandler.new

class KillHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'kill', :process_id, :identifiers ],
      :identifiers => [ [ :process_id, :identifiers ], nil ],
      :help => { :root => "Terminates processes." }
    }
    @actions = PatternAction.new([{
      :notify => [ { :missing => [ '@', 'terminate', 'missing', '*' ] } ]
    }])
  end

  def handle(parts)
    send(@actions, [ 'terminate' ].concat(parts[1...parts.length]))
  end
end
$handler['kill'] = KillHandler.new

$actions_feed = %q(
---
error:
- args-missing: [ "@", feed, error, missing, "*" ]
- command-error: [ "@", feed, error, "?", argument, unknown ]
- command-error: [ "@", feed, error, "?", duplicate, "?" ]
- feed-closed: [ "@", feed, error, closed ]
- feed-process: [ "@", feed, error, not-found ]
)

class FeedHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'feed', :process_id, :identifiers ],
      :identifiers => [ [ :process_id, :identifiers ], nil ],
      :help => { :root => "Pass current input set to processes." }
    }
    @actions = PatternAction.new([ YAML.load($actions_feed) ])
  end

  def handle(parts)
    c = $handler['input'].command_part
    parts[1...parts.length].each do |procid|
      command = [ 'feed', procid ]
      command.concat(c) unless c.empty? # Empty feed sends empty JSON object.
      send(@actions, command)
    end
  end
end
$handler['feed'] = FeedHandler.new

class EndFeedHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'close', :process_id, :identifiers ],
      :identifiers => [ [ :process_id, :identifiers ], nil ],
      :help => { :root => "Closes process input." }
    }
    @actions = PatternAction.new([{
      :notify => [ { :end_feed_not_open => [ '@', 'end-feed', 'not-open', '*' ],
        :end_feed_missing => [ '@', 'end-feed', 'missing', '*' ] } ]
    }])
  end

  def handle(parts)
    send(@actions, [ 'end-feed' ].concat(parts[1...parts.length]))
  end

  def present_other(parsed, json)
    if parsed[2] == ''
      state = "Closed:"
    elsif parsed[2] == 'not-open'
      state = "Closed already:"
    else
      return
    end
    names = parsed[3...parsed.length].join(' ')
    prompt_print "#{state} #{names}"
  end
end
$handler['close'] = EndFeedHandler.new

class RawHandler < Handler
  def initialize
    @syntax = {
      :root => [ 'raw', :json ],
      :help => { :root => "Pass unchecked JSON to datalackey." }
    }
  end

  def handle(parts)
    dump parts[1...parts.length].join('')
  end
end
$handler['raw'] = RawHandler.new


def completer(str)
  # See if we can get the command that is being typed.
  begin
    full = Readline.line_buffer.clone
  rescue NotImplementedError
    # No context available so just pick matching words.
    cands = $handler.keys.grep(/^#{Regexp.escape(str)}/)
    cands.concat $lackey_io.data.keys.grep(/^#{Regexp.escape(str)}/)
    cands.concat $lackey_io.process.keys.grep(/^#{Regexp.escape(str)}/)
    # Should add various words from syntax. Basically scan for strings.
    cands.sort!
    return cands
  end
  begin
    parts = Shellwords.shellsplit(full)
  rescue ArgumentError
    begin
      parts = Shellwords.shellsplit(full + '"')
    rescue ArgumentError
      parts = Shellwords.shellsplit(full + "'")
    end
  end
  if parts.length < 2 # We are just typing the command.
    return $handler.keys.sort.grep(/^#{Regexp.escape(str)}/)
  end
  h = $handler[parts[0]]
  return [] if h.nil?
  return h.completion_candidates(parts, str)
end
Readline.completion_proc = Proc.new { |str| completer(str) }


# Load history.
history_dir = arguments.directory.nil? ? Dir.pwd : arguments.directory
history_file = File.join(history_dir, history_file_basename)
if File.exist? history_file
  begin
    fp = File.new history_file
    fp.readlines.each { |line| Readline::HISTORY << line.chomp  }
  rescue StandardError
    STDERR.puts "Failed to read history file: #{history_file}"
  end
end

while not $exiting and line = Readline.readline($prompt, false)
  line.strip!
  begin
    parts = line.shellsplit
  rescue ArgumentError => e
    puts e.to_s
    next
  end
  next if parts.length == 0
  h = $handler[parts[0]]
  if h.nil?
    puts "Unknown command: #{parts[0]}"
    next
  end
  if $stdin.tty? and (Readline::HISTORY.length == 0 or Readline::HISTORY[Readline::HISTORY.length - 1] != line)
    Readline::HISTORY.push line
  end
  if h.verify(parts)
    h.handle(parts)
  end
end

# For recall to work, ensure there is exit in case ctrl-D was pressed.
if Readline::HISTORY.length == 0 or not Readline::HISTORY[Readline::HISTORY.length - 1].start_with? 'exit'
  Readline::HISTORY.push 'exit'
end

# Save history.
if $stdin.tty?
  begin
    fp = Pathname.new history_file
    fp.open('w') do |f|
      Readline::HISTORY.to_a.last(history_file_max_lines).each { |l| f.puts l }
    end
  rescue StandardError
    STDERR.puts "Failed to write history file: #{history_file}"
  end
end

$lackey.finish
$lackey_io.close
stderr_discarder.close
$lackey_io.finish
$presenter.finish
puts() unless $exiting
puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit $handler['exit'].code
