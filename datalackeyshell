#!/usr/bin/ruby

require 'optparse'
require 'readline'
require 'shellwords'
require 'open3'
require 'json'

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
  end

  def parse(args)
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyshell [options]"
      opts.separator ""
      opts.separator "Options:"
      opts.on("-m", "--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("-d", "--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit
      end
      opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("-p", "--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
    end
    parser.parse!(args)
    # Perform sanity checks on the values.
    if @memory and not (@directory.nil? and @permissions.nil?)
      puts "Cannot use both --memory and --directory or --permissions."
      exit
    end
    if not @memory
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      @permissions = "600" if @permissions == nil
    end
  end
end

arguments = Arguments.new
arguments.parse(ARGV)

exe = arguments.lackey
if exe == nil
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  for k in 0 ... dirs.length
    exe = File.join(dirs[k], "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  puts("datalackey not found.") if exe == nil
else
  if not File.exist?(exe) or not File.executable?(exe)
    puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe == nil

class LackeyProcess
  attr_reader :exit_code, :stdout, :stderr

  def initialize(exe, directory, permissions, memory)
    @accum_stdout = []
    @ready_stdout = Queue.new
    @unwanted_stderr = Queue.new
    args = [ exe,
        '--command-in', 'stdin', 'JSON', '--command-out', 'stdout', 'JSON' ]
    args.push('--memory') if memory
    args.concat([ '--directory', directory ]) if directory != nil
    args.concat([ '--permissions', permissions ]) if not memory
    @stdin, @stdout, @stderr, @wait_thread = Open3.popen3(*args)
    @read_stdout = Thread.new do
      while true do
        begin
          raw = @stdout.readpartial(32768)
        rescue EOFError
          break
        end
        loc = raw.index("\n")
        until loc.nil? do
          @accum_stdout.push(raw[0, loc]) if loc > 0 # Newline begins?
          # Found full line that is not empty.
          @ready_stdout.push(@accum_stdout.join) if @accum_stdout.length
          @accum_stdout.clear
          raw = raw[loc + 1, raw.length - loc - 1]
          loc = raw.index("\n")
        end
        @accum_stdout.push(raw) if raw.length > 0
      end
      @stdout.close
    end
    @read_stderr = Thread.new do
      while true do
        begin
          raw = @stderr.readpartial(32768)
        rescue EOFError
          break
        end
        # There should be nothing so no sweat on processing.
        @unwanted_stderr.push(raw)
      end
      @stderr.close
    end
  end

  def relay(message)
    @stdin.write message
  end

  def finish
    @stdin.close
    @wait_thread.join
    @exit_code = @wait_thread.value.exitstatus
  end

  def wait_output
    @read_stdout.join
    @read_stderr.join
  end

  def get_output
    return nil if @ready_stdout.empty?
    return @ready_stdout.pop
  end

  def get_lackey_error
    return nil if @unwanted_stderr.empty?
    return @unwanted_stderr.pop
  end
end

$lackey = LackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)

class OutputPresenter
  def initialize
    @handlers = Hash.new
    @present_output = Thread.new do
      last_stderr = false
      until $lackey.stdout.closed? and $lackey.stderr.closed?
        while out = $lackey.get_output
          break if out.nil?
          arr = JSON.parse(out)
          break unless @handlers.has_key? arr[0]
          keep = @handlers[arr[0]].present(arr)
          Readline.redisplay
          last_stderr = false
        end
        while out = $lackey.get_lackey_error
          break if out.nil?
          puts "STDERR:" unless last_stderr
          last_stderr = true
          puts out
        end
        sleep 0.1
      end
    end
  end

  def incoming(identifier, handler)
    @handlers[identifier] = handler
  end

  def wait_output
    @present_output.join
  end
end
$presenter = OutputPresenter.new


class IdentifierGenerator
  def initialize
    @last = 0
  end

  def get
    @last += 1
    return @last
  end
end
$identifier = IdentifierGenerator.new

# Declare command handler classes here as well as the mapping.
$handler = Hash.new
$exiting = false

$prompt = '> '
def prompt_print(message)
  puts
  puts message
  print $prompt
  STDOUT.flush
end

class Handler
  def initialize(usage_text, help_text)
    @help_text = help_text
    @usage_text = usage_text
  end

  def help
    puts "#{@usage_text} : #{@help_text}"
  end

  def usage
    puts "Usage: #{@usage_text}"
  end

  def incoming(identifier)
    $presenter.incoming(identifier, self)
  end

  def relay(message)
    $lackey.relay(message)
  end

  def present_error(parsed_array)
    prompt_print "ERROR: " + parsed_array[3..parsed_array.length].join(" ")
    return false
  end

  def present_invalid(parsed_array)
    prompt_print "INVALID: " + parsed_array[3..parsed_array.length].join("\n")
    return true
  end

  def present_missing(parsed_array)
    prompt_print "MISSING: " + parsed_array[3..parsed_array.length].join("\n")
    return true
  end

  def present_empty(parsed_array)
    if parsed_array.length > 3
      prompt_print parsed_array[3..parsed_array.length].join("\n")
    end
    return false
  end

  def present(parsed_array)
    return if parsed_array.length < 3
    if parsed_array[2] == 'error'
      return present_error parsed_array
    elsif parsed_array[2] == 'invalid'
      return present_invalid parsed_array
    elsif parsed_array[2] == 'missing'
      return present_missing parsed_array
    elsif parsed_array[2] == ''
      return present_empty parsed_array
    else
      prompt_print parsed_array[3..parsed_array.length-1].join("\n")
    end
    return false
  end
end

class HelpHandler < Handler
  def initialize
    super('help', "Print command help.")
  end

  def handle(parts)
    $handler.keys.sort.each do |key|
      $handler[key].help
    end
  end
end
$handler['help'] = HelpHandler.new

class ExitHandler < Handler
  attr_reader :code

  def initialize
    super("exit [code]", "Waits for datalackey to finish, exits with code.")
    @code = 0
  end

  def handle(parts)
    $exiting = true
    return if parts.length == 1
    if parts.length != 2
      usage
      $exiting = false
      return
    end
    begin
      @code = Integer(parts[1])
    rescue ArgumentError
      usage
      $exiting = false
    end
  end
end
$handler['exit'] = ExitHandler.new

class ListHandler < Handler
  def initialize
    super("list", "Prints out the list of labels.")
  end

  def handle(parts)
    if parts.length != 1
      usage
      return
    end
    id = $identifier.get
    incoming id
    relay "[#{id},\"list\"]"
  end
end
$handler['list'] = ListHandler.new

class SetHandler < Handler
  def initialize
    super("set label value", "Sets label to JSON-encoded value, in 'quotes' as needed.")
  end

  def handle(parts)
    if parts.length < 3
      usage
      return
    end
    v = parts[2..parts.length].join("")
    relay "{\"#{parts[1]}\":#{v}}"
  end
end
$handler['set'] = SetHandler.new

class GetHandler < Handler
  def initialize
    super("get label...", "Gets labels.")
  end

  def handle(parts)
    if parts.length < 2
      usage
      return
    end
    id = $identifier.get
    incoming id
    names = parts[1..parts.length].join('","')
    relay "[#{id},\"get\",\"#{names}\"]"
  end

  def present_empty(parsed_array)
    prompt_print parsed_array[3].to_json
    return false
  end
end
$handler['get'] = GetHandler.new

while line = Readline.readline($prompt, true)
  parts = line.shellsplit
  next if parts.length == 0
  if $handler.has_key? parts[0]
    $handler[parts[0]].handle(parts)
  else
    puts "Unknown command: #{parts[0]}"
  end
  break if $exiting

  # datalackey direct commands:
  ## {} (set label value)
  # Get (get label ...)
  # Rename (mv label new)
  # Delete (rm label)
  ## List (list [pattern])
  # Run (run) See below for all parts.
  # Processes (ps)
  # Terminate (kill identifier)
  # Feed (feed identifier [name=]label|direct name=value ...)
  # EndFeed (eof identifier)
  # StorageInfo (du) ?
  # Version (version) Prints this and datalackey versions.
  # NoOperation (ping) ?
  # Other commands for convenience with above:
  # echo on|off|last Print the command sent to datalackey always|never|last.
  # Run helper commands.
  # input name=label|direct name=value ... Construct/clear input mapping.
  # input+ name=label|direct name=value ... Append to input mapping.
  # output label=name ... Construct/clear output mapping.
  # output+ label=name ... Append to output mapping.
  # format in|out json When there is an alternative.
  # channel in|out pipe|shared_memory When there is an alternative.
  # env var=value ... Contruct/clear environment.
  # env+ var=value ... Append to environment.
  # args arguments as they are... Construct/clear program argument list.
  # args+ arguments as they are... Append to program argument list.
  # run program [eof] Run using input, output, format, channel, env, args.
  #  Optional eof indicates to close feed in the same call.
  # print input, output, format, channel, env, args Print argument state or
  #  without arguments print them all.
  # recall program input output format channel env args Fetches value from
  #  last run of program, without argumets fetches all.
  # re-run program ... Like "recall program ..." and "run program" so uses
  #  current for parts that have not been recalled.
  #  recall allows for editing values, re-run direct re-use
  # history [pattern] Shows history matching the pattern.
  
end

$lackey.finish
$lackey.wait_output
$presenter.wait_output
puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit $handler['exit'].code
