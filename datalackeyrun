#!/usr/bin/env ruby

# Argument handling and checking
# datalackey process
# Main loop

require 'optparse'
require 'open3'
require 'json'
require 'pathname'
require 'yaml'
require 'datalackeylib'


# Argument handling and checking

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions, :terminate_delay

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
    @terminate_delay = nil
  end

  def parse
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyrun [options] command params"
      opts.separator ""
      opts.separator "Options:"
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit 0
      end
      opts.on("--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("--memory", "Store data in memory.") { @memory = true }
      opts.on("--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on("--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
      opts.on('--terminate_delay DELAY', "Wait DELAY seconds before terminating remaining controller-launched processes, 0 disables.") do |d|
        @terminate_delay = d
      end
    end
    parser.parse!
    # Perform sanity checks on the values.
    begin
      @memory, @directory, @permissions =
        DatalackeyProcess.verify_memory_directory_permissions(
          @memory, @directory, @permissions)
      if @terminate_delay.nil?
        @terminate_delay = 5
      else
        @terminate_delay = Float(@terminate_delay)
        if @terminate_delay < 0
          STDERR.puts "Terminate delay less than 0."
          exit 1
        end
      end
    rescue ArgumentError => e
      STDERR.puts e.to_s
      exit 1
    end
  end
end

arguments = Arguments.new
arguments.parse

# datalackey process
begin
  $lackey_proc = DatalackeyProcess.new(arguments.lackey, arguments.directory, arguments.permissions, arguments.memory)
rescue ArgumentError => e
  puts e.to_s
  exit 1
end
lackey_stderr = StoringReader.new($lackey_proc.stderr)
$lackey = DatalackeyIO.new($lackey_proc.stdin, $lackey_proc.stdout, nil)

run_actions = YAML.load(%q(
---
return:
- run_running: [ "@", run, running, "?" ]
error:
- error: [ "@", run, error, "*" ]
- syntax: [ "@", "?", error, argument, invalid ]
- syntax: [ "@", "?", error, argument, not-integer ]
- syntax: [ "@", "?", missing, "*" ]
note:
- run_error_input_failed: [ "@", run, error, input, failed ]
- run_child_error_output_format: [ "@", run, error, format ]
- run_child_error_output_format: [ "@", error, format ]
- run_terminated: [ "@", run, terminated, "?" ]
- run_exit: [ "@", run, exit, "?" ]
- run_signal: [ "@", run, signal, "?" ]
- run_stop: [ "@", run, stopped, "?" ]
- run_continue: [ "@", run, continued ]
- run_closed: [ "@", run, input, closed ]
bytes:
- bytes: [ "@", run, bytes, "?", "*" ]
))

$output_mutex = Mutex.new
$output = []
$quitting = false
$exit_code = 0

def run_proc(category, action, message, vars)
  case category.to_s
  when 'error'
    $output_mutex.synchronize do
      $output.push "ERROR: #{action} : #{message[3...message.length].join(' ')}"
    end
    $quitting = true
  when 'note'
    case action.to_s
    when 'run_error_input_failed'
      $output_mutex.synchronize { $output.push "Input failed." }
    when 'run_child_error_output_format'
      $output_mutex.synchronize { $output.push "Output format error." }
    when 'run_terminated'
      $output_mutex.synchronize { $output.push "Terminated." }
      $quitting = true
    when 'run_exit'
      $exit_code = vars.last
      $quitting = true
    when 'run_signal'
      $output_mutex.synchronize { $output.push "Signal: #{vars.first}" }
    when 'run_stop'
      $output_mutex.synchronize { $output.push "Stopped: #{vars.first}" }
    when 'run_continue'
      $output_mutex.synchronize { $output.push "Continued." }
    end
  when 'bytes'
    $output_mutex.synchronize { $output.push ''.concat(*vars) }
  end
  return []
end

run_pa = PatternAction.new([ run_actions ],
  [ Proc.new { |ctg, act, msg, vars| run_proc(ctg, act, msg, vars) } ])

# Run the program that was given in the command-line.
cmd = [ '*', 'run' ]
cmd.concat [ "in","JSON","stdin","out","JSON","stdout","out","bytes","stderr" ]
cmd.concat [ "notify","data","notify","process" ]
cmd.concat [ "program" ]
cmd.concat argv
$lackey.send(run_pa, cmd, true)

# Main loop

def get_output
  $output_mutex.synchronize do
    result = $output
    $output = []
    return result
  end
end

def id_list_message(command, ids)
  return if ids.empty?
  cmd = [ nil, command ] # No need to get replies.
  cmd.concat ids
  $lackey.dump JSON.generate cmd
end

terminate_time = nil
until $lackey.closed?
  had_output = false
  get_output.each do |out|
    had_output = true
    puts out
  end
  lackey_stderr.readlines.each do |e|
    had_output = true
    STDERR.puts e
  end
  sleep(0.1) unless had_output
  next unless $quitting
  # Here controller has exited.
  procs = $lackey.processes
  if procs.empty?
    $lackey.close # Causes datalackey to exit. Output closing then exits the loop.
    next
  end
  if terminate_time.nil? # On first quitting, set terminate time and end feeds.
    terminate_time = Time.new + arguments.terminate_delay
    id_list_message('end-feed', procs.keys)
    next # If terminate delay is 0 this gives a little time for normal exit.
  end
  next if (Time.new <=> terminate_time) == -1
  # Time is up and there are running processes.
  id_list_message('terminate', procs.keys)
end

$lackey_proc.finish
$lackey.close
lackey_stderr.close
$lackey.finish
puts("datalackey exit: #{$lackey_proc.exit_code}") if $lackey_proc.exit_code != 0
exit $exit_code
