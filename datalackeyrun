#!/usr/bin/env ruby

# Argument handling and checking
# datalackey process
# Main loop

require 'optparse'
require 'open3'
require 'json'
require 'pathname'

# Argument handling and checking

class Arguments
  attr_reader :directory, :memory, :lackey, :permissions, :terminate_delay

  def initialize
    @directory = nil
    @memory = false
    @lackey = nil
    @permissions = nil
    @terminate_delay = nil
  end

  def parse
    parser = OptionParser.new do |opts|
      opts.banner = "Usage: datalackeyrun [options] command params"
      opts.separator ""
      opts.separator "Options:"
      opts.on("--memory", "Store data in memory.") do
        @memory = true
      end
      opts.on("--directory [DIR]", "Store data under (working) directory.") do |d|
        @directory = d || ''
      end
      opts.on_tail("-h", "--help", "Print this help and exit.") do
        puts opts
        exit 0
      end
      opts.on("--lackey PROGRAM", "Use specified datalackey executable.") do |e|
        @lackey = e
      end
      opts.on("--permissions MODE", [:user, :group, :other], "Use permissions extended to (user, group, other) for files.") do |p|
        @permissions = { :user => "600", :group => "660", :other => "666" }[p]
      end
      opts.on('--terminate_delay DELAY', "Wait DELAY seonds until teminating remaining processes, 0 disables.") do |d|
        @terminate_delay = d
      end
    end
    parser.parse!
    # Perform sanity checks on the values.
    if @memory and not (@directory.nil? and @permissions.nil?)
      STDERR.puts "Cannot use both --memory and --directory or --permissions."
      exit 1
    end
    if not @memory
      if @directory.nil?
        @directory = Dir.pwd
      elsif not Dir.exist? @directory
        STDERR.puts "Given directory does not exist: #{@directory}"
        exit 1
      end
      @permissions = "600" if @permissions.nil?
    end
    if @terminate_delay.nil?
      @terminate_delay = 5
    else
      begin
        @terminate_delay = Float(@terminate_delay)
      rescue ArgumentError => ex
        STDERR.puts ex.to_s
        exit 1
      end
      if @terminate_delay < 0
        STDERR.puts "Terminate delay less than 0."
        exit 1
      end
    end
  end
end

arguments = Arguments.new
arguments.parse

exe = arguments.lackey
if exe == nil
  dirs = [ '/usr/local/libexec', '/usr/libexec' ]
  dirs.concat ENV['PATH'].split(File::PATH_SEPARATOR)
  dirs.each do |d|
    exe = File.join(d, "datalackey")
    break if File.exist?(exe) and File.executable?(exe)
    exe = nil
  end
  STDERR.puts("datalackey not found.") if exe == nil
else
  if not File.exist?(exe) or not File.executable?(exe)
    STDERR.puts "Not found or not an executable: #{exe}"
  end
end
exit(1) if exe == nil

# datalackey process

class LackeyProcess
  attr_reader :exit_code, :stdout, :stderr

  def initialize(exe, directory, permissions, memory)
    @accum_stdout = []
    @ready_stdout = Queue.new
    @unwanted_stderr = Queue.new
    args = [ exe,
        '--command-in', 'stdin', 'JSON', '--command-out', 'stdout', 'JSON' ]
    args.push('--memory') if memory
    args.concat([ '--directory', directory ]) if directory != nil
    args.concat([ '--permissions', permissions ]) if not memory
    @stdin, @stdout, @stderr, @wait_thread = Open3.popen3(*args)
    @read_stdout = Thread.new do
      while true do
        begin
          raw = @stdout.readpartial(32768)
        rescue EOFError
          break
        end
        loc = raw.index("\n")
        until loc.nil? do
          @accum_stdout.push(raw[0, loc]) if loc > 0 # Newline begins?
          # Found full line that is not empty.
          @ready_stdout.push(@accum_stdout.join) if @accum_stdout.length
          @accum_stdout.clear
          raw = raw[loc + 1, raw.length - loc - 1]
          loc = raw.index("\n")
        end
        @accum_stdout.push(raw) if raw.length > 0
      end
      @stdout.close
    end
    @read_stderr = Thread.new do
      while true do
        begin
          raw = @stderr.readpartial(32768)
        rescue EOFError
          break
        end
        # There should be nothing so no sweat on processing.
        @unwanted_stderr.push(raw)
      end
      @stderr.close
    end
    @last_identifier = 0
  end

  def relay(message)
    @stdin.write message
  end

  def close
    @stdin.close
  end

  def finish
    @wait_thread.join
    @read_stdout.join
    @read_stderr.join
    @exit_code = @wait_thread.value.exitstatus
  end

  def get_output
    return nil if @ready_stdout.empty?
    return @ready_stdout.pop
  end

  def get_lackey_error
    return nil if @unwanted_stderr.empty?
    return @unwanted_stderr.pop
  end
end

$lackey = LackeyProcess.new(exe, arguments.directory, arguments.permissions, arguments.memory)

# Main loop

cmd = '["*","run","in","JSON","stdin","out","JSON","stdout","out","bytes","stderr","program"'
argv.each do |a|
  cmd.concat ",\"#{a}\""
end
cmd.concat ']'
$lackey.relay cmd

other_processes = {}
quitting = false
terminate_time = nil
exit_code = 0
until $lackey.stdout.closed? and $lackey.stderr.closed?
  had_output = false
  while out = $lackey.get_output
    break if out.nil?
    had_output = true
    arr = JSON.parse(out)
    if arr[1] == 'run'
      # Related to the program being run.
      if arr[2] == 'error'
        quitting = true
      elsif arr[2] == 'exit'
        exit_code = arr[3].to_i
      elsif arr[2] == 'finished' or arr[2] == 'terminated'
        unless other_processes.empty?
          # End feeds of running processes in the hopes they quit on their own.
          cmd = '[1,"end-feed"'
          other_processes.each_key do |id|
            cmd.concat ",\"#{id}\""
          end
          cmd.concat ']'
          $lackey.relay cmd
        end
        quitting = true
        if arguments.terminate_delay > 0
          terminate_time = Time.new + arguments.terminate_delay
        end
      elsif arr[2] == 'bytes'
        msg = ''
        arr[3...arr.length].each do |b|
          msg.concat b.chr
        end
        STDOUT.print msg
        STDOUT.flush
      end
    elsif arr[0].nil?
      next unless arr[1] == 'process'
      if arr[2] == 'started'
        other_processes[arr[3]] = arr[4]
      elsif arr[2] == 'ended'
        other_processes.delete arr[3]
      end
    end
    next unless quitting
    if other_processes.empty?
      $lackey.close
      next
    end
    next if terminate_time.nil?
    next if Time.new <=> terminate_time == -1
    cmd = '[2,"terminate"'
    other_processes.each_key do |id|
      cmd.concat ",\"#{id}\""
    end
    cmd.concat ']'
    $lackey.relay cmd
    terminate_time = nil
  end
  # There should not be anything here.
  while out = $lackey.get_lackey_error
    break if out.nil?
    STDOUT.puts out
    had_output = true
  end
  sleep(0.1) unless had_output
end

$lackey.finish
STDERR.puts("datalackey exit status: #{$lackey.exit_code}") if $lackey.exit_code != 0
exit exit_code
