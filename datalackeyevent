#!/usr/bin/env ruby

require 'optparse'
require 'yaml'
require 'json'
require 'datalackeylib'

$CMDOUT = STDOUT
$USEROUT = STDERR

root_dir = Dir.pwd

parser = OptionParser.new do |opts|
  opts.banner = "Usage: datalackeyevent [options] event-files..."
  opts.separator ""
  opts.separator "Options:"
  opts.on('-o', '--stdout', 'Use stdout as command output, stderr for user.') do
    $CMDOUT = STDOUT
    $USEROUT = STDERR
  end
  opts.on('-e', '--stderr', 'Use stderr as command output, stdout for user.') do
    $CMDOUT = STDERR
    $USEROUT = STDOUT
  end
  opts.on_tail('-h', '--help', 'Print this help and exit.') do
    $USEROUT.puts opts
    exit 0
  end
end
parser.parse!


# datalackey output to event mapping. Needs to support finding the most specific
# mapping so that we can have generic ones and exact ones.
#  Just sort to decreasing specificness and keep original order.
#  Pick first match, or keep original order and keep most specific match.
# mapping from event to actions it affects. Consider regexps. Possible? Yes,
#  since event is a string list and we can pre-check all matches.
# mapping from action events to events list to check if triggered?
# Order of triggering? First in list first.

# Everything is a mapping.
# event: input: list of input: from-datalackey, event: string
#  What about mapping multiple events to one? Like errors?
#  input: List of strings is one item, list of lists multiple.
#  Also mapping list output to individual events.
# Event is a string, and event in action can be a regexp.
# events: actions: mapping with at least action.
#  events: is a list of strings (regexps) where all are required to trigger.
#  actions: is a list of whatever they need to be.
# Eventless actions trigger automatically.
# If action is to be triggered explicitly from another action, specify unique
# event name.

# Eventfile:
---
- labels:
  - list
  - of
  - labels
  commands:
  - list # Actions insignificant?
  - of # Enough if they do not fail?
  - commands # Wait until all done? Same problem as in Makefile.


# Sort out actions in case some initialize triggers one. Or given variables,
# should they be handled in the order they are given?

# Data notifications simplified to store/delete. Rename is explicit here so
# does it need anything? Maybe for completeness.
# Add could respond to store/rename target and remove to delete/rename source.

# Processes technically need start/end. End-feed signals that it should quit.
# If termination is desired, one can't really say how long the delay should be.

# Errors with missing values or duplicates ought to be handled.

# All conditions are stored with references to action object condition.
# List of all conditions is used to turn on individual condition triggers.
# When condition triggers in object it checks if all have been triggered.
# Condition trigger checks can be mappings to values when they are constants.
# Variable names could be used as is and mapping from value to varibles is used
#  to add another value to check for in the mapping. Hence same trigger type
#  but multiple values checked at once to cover all variables.
# Alternatively just go through all in a list. Technically bad as linear time.
# Could represent in some hashable form.
# Inverse mapping from value to variable seems needed for speed.
# Is the order of conditions important? Gather all that fully trigger and
# then perform first to last.



# A category, action, vars triplet. Where does vars fit in action?

# Each command will specify PatternAction to use and the action is
# the actions to look for. Allow second value be how vars is called so that
# multiple conditions can have their own variables.

# Message generator could also map action/vars to name that contains
# vars array since the name covers the pair and contains variables. The pair
# is atomic for purposes of recognizing it.

# Note that error and return categories should be there unless execute until
# done is desired. Only seriously affects run.

# Use convenience wrapper for PatternAction that automatically sets the
# callback that maps vars to the single value.

# Could maintain list of running programs to use end-feed with on error?

# Things like end-feed could be variables and there are some functions that
# are called and their place replaced with return value just like variable
# checks. Finally flatten the list. Treat values like variables that change
# value automatically.

# Except for run and feed the commands are simple.
# The I/O part of run can be rolled into "pipes" and I/O mapping left entirely
# to the user.


