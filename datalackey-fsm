#!/usr/bin/env ruby

require 'optparse'
require 'yaml'
require 'json'
require 'datalackeylib'


$CMDOUT = STDOUT
$USEROUT = STDERR
$OVERWRITE_ACTION = nil
# For case when we run datalackey.
$LACKEY = nil
$MEMORY = nil
$DIRECTORY = nil
$PERMISSIONS = nil

root_dir = Dir.pwd

parser = OptionParser.new do |opts|
  opts.banner = "Usage: datalackey-fsm [options] state-files..."
  opts.separator ""
  opts.separator "Options:"
  opts.on_tail('-h', '--help', 'Print this help and exit.') do
    $USEROUT.puts opts
    exit 0
  end
  # For case where this is beng run under datalackey.
  opts.on('-o', '--stdout', 'Use stdout as command output, stderr for user.') do
    $CMDOUT = STDOUT
    $USEROUT = STDERR
  end
  opts.on('-e', '--stderr', 'Use stderr as command output, stdout for user.') do
    $CMDOUT = STDERR
    $USEROUT = STDOUT
  end
  opts.on('-w', '--warn', 'Print warning when state is overwritten.') do
    $OVERWRITE_ACTION = :warn
  end
  opts.on('--error', 'State overwriting is an error.') do
    $OVERWRITE_ACTION = :error
  end
  # For case where this process runs datalackey.
  opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
    $LACKEY = e
  end
  opts.on("-m", "--memory", "Store data in memory.") { $MEMORY = true }
  opts.on("-d", "--directory [DIR]",
      "Store data under (working) directory.") do |d|
    $DIRECTORY = d || ''
  end
  opts.on("-p", "--permissions MODE", [:user, :group, :other],
      "Use permissions extended to (user, group, other) for files.") do |p|
    $PERMISSIONS = { :user => "600", :group => "660", :other => "666" }[p]
  end
end
parser.parse!

if ARGV.empty?
  $USEROUT.puts "No state files."
  exit 1
end

$userout_mutex = Mutex.new
def userout(message)
  $userout_mutex.synchronize { $USEROUT.puts message }
end

class Machine
  attr_accessor :variables

  def initialize
    @commands = Hash.new(nil)
    @signal_mutex = Mutex.new
    @signal = nil
    @signal2state = { }
    @variables = Hash.new(nil)
  end

  def register(name, object)
    raise ArgumentError.new("Command name is not a string.") unless name.is_a? String
    @commands[name] = object
  end

  def get_binding
    return binding
  end

  def expand(item, info, seen = [])
    if item.is_a? Array
      info.push '['
      result = []
      item.each { |v| result.push expand(v, info, seen) }
      info.push ']'
      return result
    end
    if item.is_a? Hash
      info.push '{'
      result = { }
      item.each_pair { |k, v| result[k] = expand(v, info, seen) }
      info.push '}'
      return result
    end
    info.concat([ ',', item ]) unless info.last == item
    if item.is_a?(String) and item.start_with?('$') and ENV.has_key? item[1...item.length]
      item = ENV[item[1...item.length]]
      info.concat [ '=>', item ]
      return expand(item, info, seen)
    end
    if @variables.has_key? item
      s = seen.clone
      s.push item
      raise "Loop: #{item} via #{s.join(' => ')}." if seen.include? item
      item = @variables[item]
      info.concat [ '=>', item ]
      return expand(item, info, s)
    end
    return item
  end

  def set_signal(sig)
    @signal_mutex.synchronize do
      @signal = sig if @signal.nil? or sig == 'error'
    end
  end

  def set_error(message)
    userout message
    set_signal('error')
  end

  def get_signal
    @signal_mutex.synchronize { @signal }
  end

  def wipe_signal
    @signal_mutex.synchronize do
      sig = @signal
      @signal = nil
      return sig
    end
  end

  def run_state(state)
    state[:commands].each do |cmd|
      info = []
      begin
        expanded = expand(cmd, info)
      rescue RuntimeError => e
        set_error e.to_s
        return
      end
      handler = nil
      if expanded.is_a? String
        handler = @commands[expanded]
        set_error("Unknown command: #{expanded}") if handler.nil?
      elsif expanded.is_a? Array
        handler = @commands[expanded.first]
        set_error("Unknown command: #{expanded.first}") if handler.nil?
      elsif expanded.is_a? Hash
        @commands.each_pair do |name, hndlr|
          if cmd.has_key? name # Registred names should be unique.
            handler = hndlr
            break
          end
        end
        set_error("Match for dictionary keys not found.") if handler.nil?
      end
      break if handler.nil? or not get_signal.nil?
      handler.handle(expanded)
    end
  end

  def run(initial_state_name, states)
    finalized = false
    name = initial_state_name
    while states.has_key? name
      finalized = true if name == '__terminate_all'
      state = states[name]
      if state.has_key? 'global_signal2state'
        @signal2state = state['global_signal2state']
      end
      run_state(state)
      sig = wipe_signal
      if state.has_key?('signal2state') and state['signal2state'].has_key? sig
        name = state['signal2state'][sig]
      elsif @signal2state.has_key? sig
        name = @signal2state[sig]
      else
        name = nil
      end
      break if name.nil?
      unless states.has_key? name
        userout "Transition to unknown state: #{name}"
        break
      end
    end
    if not finalized and states.has_key? '__terminate_all'
      run_state(states['__terminate_all'])
    end
  end
end
$machine = Machine.new

$signal_sender = Proc.new do |category, action, message, vars|
  case category
  when 'error'
    $machine.set_signal('error')
    [ message.join(' ') ]
  else []
  end
end

class Command
  attr_reader :action

  def initialize(name)
    $machine.register(name, self)
  end

  def handle(cmd)
    $lackey.send(@action, cmd)
  end
end

# Variable support, simple assign and use, leave value changes to shell?
# Dictionary of name to value mappings.
class SetCommand < Command
  def initialize
    super('set')
  end

  def handle(cmd)
    $machine.variables[cmd[1]] = (cmd.length == 3) ? cmd[2] : cmd[2...cmd.length]
  end
end
SetCommand.new

# - run to execute until end, end-feed implied
#   - maybe exit code and style signal mapping

# The rules should actually be syntax from datalackey.
# PatternAction message generator should create signals.

# List that starts with run.
class RunBase < Command
  @@actions_run_common = YAML.load(%q(
---
error:
- args_missing: [ "@", run, error, missing, "*" ]
- syntax: [ "@", run, error, "?", argument, unknown ]
- syntax: [ "@", run, error, "?", duplicate, "?" ]
- command_error: [ "@", run, error, "*" ]
- run_internal: [ "@", run, error, exception ]
- run_internal: [ "@", run, error, no-memory ]
- run_internal: [ "@", run, error, no-processes ]
- run_internal: [ "@", run, error, no-thread ]
- run_internal: [ "@", run, error, pipe ]
note:
- run_error_input_failed: [ "@", run, error, input, failed ]
- run_child_error_output_format: [ "@", run, error, format ]
- run_child_error_output_format: [ "@", error, format ]
bytes:
- bytes: [ "@", run, bytes, "?", "*" ]
))
  @@prev_bytes_mutex = Mutex.new
  @@prev_bytes_id = nil

  def initialize(name)
    @msgmaker = Proc.new do |category, action, message, vars|
      message_maker(category, action, message, vars)
    end
    super(name)
  end

  def message_maker(category, action, message, vars)
    out = []
    case category
    when 'note'
      case action
      when 'run_error_input_failed'
        out.push "Output to #{message[0]} failed."
      when 'run_child_error_output_format'
        out.push "Output to #{message[0]} failed."
      end
    when 'bytes'
      id = message[0]
      @@prev_bytes_mutex.synchronize do
        if id != @@prev_bytes_id
          out.push "#{id}:"
          @prev_bytes_id = id
        end
      end
      out.push ''.concat(*vars)
    end
    return out
  end
end

class RunCommand < RunBase
  def initialize
    super('run')
    @action = PatternAction.new([ @@actions_run_common ],
      [ @msgmaker, $signal_sender ])
  end

  def handle(cmd)
    unless cmd.include? 'end-feed'
      c = cmd[0...2]
      c.push 'end-feed'
      c.concat cmd[2...cmd.length]
      cmd = c
    end
    super(cmd)
  end
end
RunCommand.new

# - launch to return on finish and leave running, has to allow identifier
#   - possible signal for various exits, how to handle after moved other state?
#   - keeping process running is intermediate program responsibility.

# List starts with launch.
class LaunchCommand < RunBase
  def initialize
    super('launch')
    @action = PatternAction.new([
      { 'return' => [{ 'run' => [ '@', 'run', 'running', '?' ] }] },
      @@actions_run_common ], [ @msgmaker, $signal_sender ])
  end

  def handle(cmd)
    cmd[0] = 'run'
    super(cmd)
  end
end
LaunchCommand.new


class ProcessCommand < Command
  def initialize(name)
    @action = PatternAction.new([], [ $signal_sender ])
    super(name)
  end

  def handle(cmd)
    if cmd.length == 1
      $lackey.process.each_key { |k| cmd.push k }
    end
    super(cmd)
  end
end

# List sttarts with close and then lists all identifiers to close.
class CloseCommand < ProcessCommand
  def initialize
    super('close')
  end
end
CloseCommand.new

# List starts with kill and then lists all identifiers to terminate.
class KillCommand < ProcessCommand
  def initialize
    super('terminate')
  end
end
KillCommand.new

# List starts with input and is one list or list of triples.
class FeedCommand < Command
  def initialize
    super('feed')
    @action = PatternAction.new(
      [ { 'error' => [ { 'error' => [ '@', 'feed', 'error', '*' ] } ] } ],
      [ $signal_sender ])
  end
end
FeedCommand.new

# List of wait, timeout in seconds and optional process identifiers to quit.
class WaitCommand < Command
  def initialize
    super('wait')
  end

  def handle(cmd)
    begin
      deadline = Time.new + Float(cmd[1])
    rescue ArgumentError
      $machine.set_error "Not a number: #{cmd[1]}"
      return
    end
    waited = (cmd.length > 2) ? cmd[2...cmd.length] : $lackey.process.keys
    while (Time.new <=> deadline) == -1
      sleep(0.1)
      remains = false
      current = $lackey.process.keys
      waited.each { |id| remains = (remains or current.include? id) }
      return unless remains
    end
  end
end
WaitCommand.new

# List starts with delete and then all identifiers to delete.
class DeleteCommand < Command
  def initialize
    super('delete')
    @action = PatternAction.new([])
  end
end
DeleteCommand.new

# List starts with rename and then old new pairs the rest of the list.
class RenameCommand < Command
  def initialize
    super('rename')
    @action = PatternAction.new([])
  end
end
RenameCommand.new

# - shell by using an executable name and put the exe and all after it after #!
#   - arguments as a list, recognize variables
#   - provide script as a multi-line string
#   - provide a way to store output to a variable
#   - special case ruby inlined code, eval and context etc.

# Split to shell (sets command interpreter), argv, script, stdout, stderr?

class PrintCommand < Command
  def initialize
    super('print')
  end

  def handle(cmd)
    userout cmd[1...cmd.length].join(' ')
  end
end
PrintCommand.new

class ShellCommand < Command
  def initialize
    @rule =  { 'argv' => '*', 'script' => '*', 'stdout' => '?', 'stderr' => '?', '*' => '*' }
    super('script')
  end

  def handle(cmd)
    # Get interpreter and check that it exists.
    argv = cmd.fetch('argv', [])
    cmd.delete 'argv'
    script = cmd['script'] # Pre-requisite for getting this far, exists.
    vout = cmd.fetch('stdout', nil)
    cmd.delete 'stdout'
    verr = cmd.fetch('stderr', nil)
    cmd.delete 'stderr'
    vin = cmd.fetch('stdin', nil)
    cmd.delete 'stdin'
    if cmd.length != 1
      $machine.set_error "Multiple interpreter candidates."
      return
    end
    interpreter = cmd.keys.first
    hashbangargs = cmd[cmd.keys.first]
    hashbangargs = hashbangargs.join(' ') if hashbangargs.is_a? Array
    unless File.exist?(interpreter) and File.executable?(interpreter)
      $machine.set_error "Not found or not an executable: #{interpreter}"
      return
    end
    # Write script into a temporary file.
    temp = Tempfile.new('fsm', Dir.tmpdir, :mode => 0700)
    begin
      temp.puts "#!#{interpreter} #{hashbangargs}"
      temp.puts script
      temp.close
      argv.prepend temp.path
      # Run script with arguments.
      stdin, stdout, stderr, wait = Open3.popen(*argv)
      rd_out = vout.nil? ? DiscardReader.new(stdout) : StoringReader.new(stdout)
      rd_err = verr.nil? ? DiscardReader.new(stderr) : StoringReader.new(stderr)
      stdin.puts(vin) unless vin.nil?
      stdin.close
      wait.join
      $machine.variables[vout] = rd_out.readlines.join('\n') unless vout.nil?
      $machine.variables[verr] = rd_err.readlines.join('\n') unless verr.nil?
      exitcode = wait.value.exitstatus
      $machine.set_error("Shell exit: #{exitcode}") if exitcode != 0
    ensure
      temp.close!
    end
  end
end
ShellCommand.new

class RubyCommand < Command
  def initialize
    super('ruby')
  end

  def handle(cmd)
    # If variable substitution is needed, the varibles need to be full strings.
    script = cmd['ruby']
    script = script.join('\n') if script.is_a? Array
    if not eval(script, $machine.get_binding)
      # Unmodified script is visible in state files and modified here.
      $machine.set_error "Eval failed: #{script}"
    end
  end
end
RubyCommand.new

class WaitSignalCommand < Command
  def initialize
    super('wait_signal')
  end

  def handle(cmd)
    while $machine.get_signal.nil?
      sleep(0.1)
    end
  end
end
WaitSignalCommand.new

# Load and parse all state files here.

$overwrites = []

def add_states(states, new_states)
  new_states.each_pair do |name, state|
    if states.has_key? name
      $overwrites.push({ :state => name }.merge(state[:load]))
    end
    states[name] = state
  end
end

$built_ins = { '__setup' => %q(
---
- __terminate_all:
  - close
  - wait terminate_delay
  - terminate
  comment: "Default termination, close feeds, terminate all after 5 seconds."
- __setup:
  - set pipes in JSON stdin out JSON stdout
  - set pipes_stderr in JSON stdin out JSON stdout out bytes stderr
  - set notify_all notify data notify process
  - [ set, terminate_delay, 5 ]
  global_signal2state:
    error: __terminate_all
  comment: |
    First state to run. Default variable set-up. Program will add first state
    in the first item of the first file with null key unless you set it when
    replacing this. Several states in the first item results in random pick.
) }

$first_state = nil

def load_statefile(filename, current_directory)
  if $built_ins.has_key? filename
    fullname = filename
    contents = YAML.load($built_ins[filename])
    directory = '(built-in)' # Built-in can include only another built-in.
  else
    begin
      fullname = File.realpath(filename, current_directory)
      contents = YAML.load(File.read(fullname))
      directory = File.dirname(fullname)
    rescue Errno::ENOENT
      userout "Could not find #{filename} from #{current_directory}"
      return nil
    rescue StandardError
      userout "Failed to read #{filename} from #{current_directory}"
      return nil
    end
  end
  unless contents.is_a? Array
    userout "Not a top level array: #{filename} from #{current_directory}"
    return nil
  end
  states = { }
  contents.each_index do |index|
    item = contents[index]
    # There may be several states with common goto etc, get common ones apart.
    common = { :load => { :source => fullname, :index => index } }
    begin
      item.delete 'comment'
      [ 'global_signal2state', 'signal2state', 'label2signal' ].each do |shared|
        next unless item.has_key? shared
        common[shared] = item[shared]
        item.delete shared
      end
    rescue NoMethodError
      userout "Item is not a mapping: #{fullname} : #{index}"
      return nil
    end
    include_name = item.fetch('include', nil)
    if include_name.nil?
      # Separate each state while keeping common parts.
      item.each_pair do |state, commands|
        $first_state = state if $first_state.nil?
        commands.each_index do |k|
          commands[k] = commands[k].split(' ') if commands[k].is_a? String
        end
        separated = common.clone
        separated[:commands] = commands
        add_states(states, { state => separated })
      end
    else
      included = load_statefile(include_name, directory)
      if included.nil?
        userout " .. #{fullname} : #{index}"
        return nil
      end
      add_states(states, included)
    end
  end
  return states
end

states = load_statefile('__setup', root_dir)
$first_state = nil
ARGV.each do |filename|
  new_states = load_statefile(filename, root_dir)
  exit(2) if new_states.nil?
  add_states(states, new_states)
end

if not $OVERWRITE_ACTION.nil? and not $overwrites.empty?
  $overwrites.each do |ow|
    userout "#{ow[:state]} replaced by #{ow[:source]} : #{ow[:index]}"
  end
  exit(4) if $OVERWRITE_ACTION == :error
end

unless states['__setup'].has_key? 'signal2state'
  states['__setup']['signal2state'] = { }
end
unless states['__setup']['signal2state'].has_key? nil
  states['__setup']['signal2state'][nil] = $first_state
end

# State has
# - label to signal mapping
# Output mapping independent of run command for multi-feed programs? State?


if $LACKEY.nil? and $MEMORY.nil? and $DIRECTORY.nil?
  # Running under datalackey.
  unless $PERMISSIONS.nil?
    userout "Cannot give --permissions/-p unless running datalackey."
    exit 1
  end
  userout "Running under datalackey."
  $lackey_proc = DatalackeyParentProcess.new($CMDOUT, STDIN)
  $lackey_stderr = DiscardReader.new($lackey_proc.stderr)
  $lackey = DatalackeyIO.new(
    $lackey_proc.stdin, $lackey_proc.stdout, nil)
else
  begin
    $DIRECTORY, $PERMISSIONS, $MEMORY =
      DatalackeyProcess.verify_directory_permissions_memory(
        $DIRECTORY, $PERMISSIONS, $MEMORY)
    $lackey_proc = DatalackeyProcess.new(
      $LACKEY, $DIRECTORY, $PERMISSIONS, $MEMORY)
  rescue ArgumentError => e
    userout e.to_s
    exit 1
  end
  $lackey_stderr = StoringReader.new($lackey_proc.stderr)
  $lackey = DatalackeyIO.new($lackey_proc.stdin, $lackey_proc.stdout,
    Proc.new { |msgs| msgs.each { |m| userout m } })
end

$machine.run('__setup', states)

$lackey_proc.finish
$lackey.close
$lackey_stderr.close
$lackey.finish
userout("datalackey exit: #{$lackey_proc.exit_code}") if $lackey_proc.exit_code != 0
exit 
