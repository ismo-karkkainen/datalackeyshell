#!/usr/bin/env ruby

require 'optparse'
require 'yaml'
require 'json'
require 'tempfile'
require 'datalackeylib'


$CMDOUT = STDOUT
$USEROUT = STDERR
$OVERWRITE_ACTION = nil
$FOLLOW = 0
$QUIET = false
# For case when we run datalackey.
$LACKEY = nil
$MEMORY = nil
$DIRECTORY = nil
$PERMISSIONS = nil
$ECHO = false

$root_dir = Dir.pwd

parser = OptionParser.new do |opts|
  opts.summary_indent = '  '
  opts.summary_width = 26
  opts.banner = "Usage: datalackey-fsm [options] state-files..."
  opts.separator ""
  opts.separator "Options:"
  opts.on_tail('-h', '--help', 'Print this help and exit.') do
    $USEROUT.puts opts
    exit 0
  end
  opts.on('-o', '--stdout', 'Use stdout as command output, stderr for user.') do
    $CMDOUT = STDOUT
    $USEROUT = STDERR
  end
  opts.on('-e', '--stderr', 'Use stderr as command output, stdout for user.') do
    $CMDOUT = STDERR
    $USEROUT = STDOUT
  end
  opts.on('-q', '--quiet', 'Suppress normal command output.') do
    $QUIET = true
  end
  opts.separator 'Options for error checking and tracking execution:'
  opts.on('-w', '--warn', 'Print warning when state is overwritten.') do
    $OVERWRITE_ACTION = :warn
  end
  opts.on('--error', 'State overwriting is an error.') do
    $OVERWRITE_ACTION = :error
  end
  opts.on('-f', '--follow [LEVEL]', Integer, 'Print state/signal/command.') do |level|
    $FOLLOW = level
  end
  opts.separator 'Options for case where this process runs datalackey:'
  opts.on("-l", "--lackey PROGRAM", "Use specified datalackey executable.") do |e|
    $LACKEY = e
  end
  opts.on("-m", "--memory", "Store data in memory.") { $MEMORY = true }
  opts.on("-d", "--directory [DIR]",
      "Store data under (working) directory.") do |d|
    $DIRECTORY = d || ''
  end
  opts.on("-p", "--permissions MODE", [:user, :group, :other],
      "File permissions cover (user, group, other).") do |p|
    $PERMISSIONS = { :user => "600", :group => "660", :other => "666" }[p]
  end
  opts.on('--echo', 'Echo communication with datalackey.') do
    $ECHO = true
  end
end
parser.parse!

if ARGV.empty?
  $USEROUT.puts "No state files."
  exit 1
end

$userout_mutex = Mutex.new
def userout(message)
  return if message.is_a?(Array) and message.empty?
  message = [ message ] unless message.is_a? Array
  $userout_mutex.synchronize do
    message.each { |m| $USEROUT.puts m }
  end
end

class Machine
  attr_accessor :variables
  attr_reader :had_error, :state

  def initialize
    @commands = Hash.new(nil)
    @skip_expand = { }
    @signal_mutex = Mutex.new
    @signal = nil
    @variables = Hash.new(nil)
    @label2signal_mutex = Mutex.new
    @label2signal = { }
  end

  def register(name, object)
    raise ArgumentError.new("Command name is not a string.") unless name.is_a? String
    @commands[name] = object
  end

  def expand_skip(name, count)
    @skip_expand[name] = count
  end

  def get_binding
    return binding
  end

  def expand(item, info, seen = [])
    if item.is_a? Array
      info.push '['
      result = []
      item.each { |v| result.push expand(v, info, seen) }
      info.push ']'
      return result
    end
    if item.is_a? Hash
      info.push '{'
      result = { }
      item.each_pair { |k, v| result[k] = expand(v, info, seen) }
      info.push '}'
      return result
    end
    info.concat([ ',', item ]) unless info.last == item
    if item.is_a?(String) and item.start_with?('$') and ENV.has_key? item[1...item.length]
      item = ENV[item[1...item.length]]
      info.concat [ '=>', item ]
      return expand(item, info, seen)
    end
    if @variables.has_key? item
      s = seen.clone
      s.push item
      raise "Loop: #{item} via #{s.join(' => ')}." if seen.include? item
      item = @variables[item]
      info.concat [ '=>', item ]
      return expand(item, info, s)
    end
    return item
  end

  def set_signal(sig)
    @signal_mutex.synchronize do
      if @signal.nil? or sig == 'error'
        userout "Signal: #{sig}" if $FOLLOW > 0
        @signal = sig
        @had_error = @signal == 'error'
      end
    end
  end

  def set_error(message)
    userout message
    set_signal('error')
  end

  def get_signal
    @signal_mutex.synchronize { @signal }
  end

  def wipe_signal
    @signal_mutex.synchronize do
      sig = @signal
      @signal = nil
      return sig
    end
  end

  def label2signal
    @label2signal_mutex.synchronize { @label2signal }
  end

  def run_state(state, name)
    userout "State: #{name}" if $FOLLOW > 0
    @state = state # Command may need e.g. the location of the state file.
    state[:commands].each do |cmd|
      info = []
      begin
        userout "Command: #{cmd.to_s}" if $FOLLOW > 2
        if cmd.is_a? Hash
          expanded = expand(cmd, info)
        else
          skip = @skip_expand.fetch(cmd.first, 0)
          skip = cmd.length if cmd.length < skip
          expanded = cmd[0...skip]
          rest = cmd[skip...cmd.length]
          rest = [ rest ] unless rest.is_a? Array
          expanded.concat expand(rest, info)
        end
        userout "Expanded: #{expanded.to_s}" if $FOLLOW > 3
      rescue RuntimeError => e
        set_error e.to_s
        return
      end
      handler = nil
      if expanded.is_a? String
        handler = @commands[expanded]
        userout "Command: #{expanded}" if $FOLLOW == 2
        set_error("Unknown command: #{expanded}") if handler.nil?
      elsif expanded.is_a? Array
        handler = @commands[expanded.first]
        userout "Command: #{expanded.first}" if $FOLLOW == 2
        set_error("Unknown command: #{expanded.first}") if handler.nil?
      elsif expanded.is_a? Hash
        @commands.each_pair do |name, hndlr|
          if cmd.has_key? name # Registred names should be unique.
            userout "Command: #{name}" if $FOLLOW == 2
            handler = hndlr
            break
          end
        end
        set_error("Match for dictionary keys not found.") if handler.nil?
      end
      break if handler.nil? or not get_signal.nil?
      handler.handle(expanded)
      break unless get_signal.nil? # Prevents follow-output for next command.
    end
  end

  def run(initial_state_name, states)
    last_state_name = '__terminate_all'
    finalized = false
    name = initial_state_name
    signal2state = { } # Only changes when state has new global mapping.
    while states.has_key? name
      finalized = true if name == last_state_name
      state = states[name]
      signal2state = state.fetch('global_signal2state', signal2state)
      @label2signal_mutex.synchronize do
        @label2signal = state.fetch('label2signal', { })
      end
      run_state(state, name)
      @label2signal_mutex.synchronize { @label2signal = { } }
      sig = wipe_signal
      name = state.fetch('signal2state', { }).fetch(sig, nil)
      name = signal2state.fetch(sig, nil) if name.nil?
      break if name.nil?
      unless states.has_key? name
        userout "Transition to unknown state: #{name}"
        break
      end
      userout($lackey_stderr.readlines) unless $QUIET
    end
    if not finalized and states.has_key? last_state_name
      run_state(states[last_state_name], last_state_name)
    end
  end
end
$machine = Machine.new

$signal_sender = Proc.new do |category, action, message, vars|
  case category
  when 'error'
    $machine.set_error(message.join(' '))
  when 'exit'
    if action == 'code' and vars.first != 0
      $machine.set_error(message.join(' '))
    end
  end
end

class Command
  attr_reader :action

  def initialize(name)
    $machine.register(name, self)
  end

  def handle(cmd)
    cmd.flatten!
    userout(cmd.to_s) if $FOLLOW > 4
    $lackey.send(@action, cmd)
  end
end

class SetCommand < Command
  def initialize
    super('set')
    $machine.expand_skip('set', 2)
  end

  def handle(cmd)
    $machine.variables[cmd[1]] = (cmd.length == 3) ? cmd[2] : cmd[2...cmd.length]
  end
end
SetCommand.new

class UnsetCommand < Command
  def initialize
    super('unset')
    $machine.expand_skip('set', 1000000)
  end

  def handle(cmd)
    cmd.flatten!
    cmd.shift
    cmd.each { |name| $machine.variables.delete name }
  end
end
UnsetCommand.new

class IsSetCommand < Command
  def initialize
    super('is_set')
    $machine.expand_skip('set', 1000000) # Variable names must not be expanded.
  end

  def handle(cmd)
    cmd.flatten!
    cmd.shift
    unset = []
    cmd.each { |name| unset.push(name) unless $machine.variables.has_key? name }
    $machine.set_error("Not set: #{unset.join('\n')}") unless unset.empty?
  end
end
IsSetCommand.new

class RunBase < Command
  @@actions_run_common = YAML.load(%q(
---
error:
- args_missing: [ "@", run, error, missing, "*" ]
- syntax: [ "@", run, error, "?", argument, unknown ]
- syntax: [ "@", run, error, "?", duplicate, "?" ]
- command_error: [ "@", run, error, "*" ]
- run_internal: [ "@", run, error, exception ]
- run_internal: [ "@", run, error, no-memory ]
- run_internal: [ "@", run, error, no-processes ]
- run_internal: [ "@", run, error, no-thread ]
- run_internal: [ "@", run, error, pipe ]
note:
- run_error_input_failed: [ "@", run, error, input, failed ]
- run_child_error_output_format: [ "@", run, error, format ]
- run_child_error_output_format: [ "@", error, format ]
exit:
- code: [ "@", run, exit, "?" ]
bytes:
- bytes: [ "@", run, bytes, "?", "*" ]
))
  @@prev_bytes_mutex = Mutex.new
  @@prev_bytes_id = nil

  def initialize(name)
    @msgmaker = Proc.new do |category, action, message, vars|
      message_maker(category, action, message, vars)
    end
    super(name)
  end

  def message_maker(category, action, message, vars)
    out = []
    case category
    when 'note'
      case action
      when 'run_error_input_failed'
        out.push "Output to #{message[0]} failed."
      when 'run_child_error_output_format'
        out.push "Output to #{message[0]} failed."
      end
    when 'bytes'
      id = message[0]
      @@prev_bytes_mutex.synchronize do
        if id != @@prev_bytes_id
          out.push "#{id}:"
          @prev_bytes_id = id
        end
      end
      out.push ''.concat(*vars)
    end
    return out
  end

  def handle(cmd)
    t = cmd[0] # Swap command and user-given identifier.
    cmd[0] = cmd[1]
    cmd[1] = t
    # Locate executable unless absolute path.
    idx = cmd.index 'program'
    unless idx.nil? or idx + 1 == cmd.length
      cmd[idx + 1] = DatalackeyProcess.locate_executable(cmd[idx + 1],
        [ Dir.pwd, $root_dir, File.dirname($machine.state[:load][:source]) ])
    end # Missing program will be found normally and causes error.
    userout(cmd.to_s) if $FOLLOW > 4
    $lackey.send(@action, cmd, true)
  end
end

class RunCommand < RunBase
  def initialize
    super('run')
    @action = PatternAction.new([ @@actions_run_common ],
      [ @msgmaker, $signal_sender ])
  end

  def handle(cmd)
    cmd.flatten!
    unless cmd.include? 'end-feed'
      c = cmd[0...2]
      c.push 'end-feed'
      c.concat cmd[2...cmd.length]
      cmd = c
    end
    super(cmd)
  end
end
RunCommand.new

class LaunchCommand < RunBase
  def initialize
    super('launch')
    @action = PatternAction.new([
      { 'return' => [{ 'run' => [ '@', 'run', 'running', '?' ] }],
        'error' => [{ 'term' => [ '@', 'run', 'terminated', '?' ] }]},
      @@actions_run_common ], [ @msgmaker, $signal_sender ])
  end

  def handle(cmd)
    cmd.flatten!
    cmd[0] = 'run'
    super(cmd)
  end
end
LaunchCommand.new


class ProcessCommand < Command
  def initialize(name)
    @action = PatternAction.new([], [ $signal_sender ])
    super(name)
  end

  def handle(cmd)
    cmd.flatten!
    cmd.concat($lackey.process.keys) if cmd.length == 1
    super(cmd)
  end
end

class CloseCommand < ProcessCommand
  def initialize
    super('close')
  end

  def handle(cmd)
    cmd.flatten!
    cmd[0] = 'end-feed'
    super(cmd)
  end
end
CloseCommand.new

class TerminateCommand < ProcessCommand
  def initialize
    super('terminate')
  end
end
TerminateCommand.new

class FeedCommand < Command
  def initialize
    super('feed')
    @action = PatternAction.new(
      [ { 'error' => [ { 'error' => [ '@', 'feed', 'error', '*' ] } ] } ],
      [ $signal_sender ])
  end
end
FeedCommand.new

class WaitProcessCommand < Command
  def initialize
    super('wait_process')
  end

  def handle(cmd)
    cmd.flatten!
    begin
      deadline = Time.new + Float(cmd[1])
    rescue ArgumentError
      $machine.set_error "Not a number: #{cmd[1]}"
      return
    end
    waited = (cmd.length > 2) ? cmd[2...cmd.length] : $lackey.process.keys
    while (Time.new <=> deadline) == -1
      sleep(0.2)
      remains = false
      current = $lackey.process.keys
      waited.each { |id| remains = (remains or current.include? id) }
      return unless remains
    end
  end
end
WaitProcessCommand.new

class WaitDataCommand < Command
  def initialize
    super('wait_data')
  end

  def handle(cmd)
    cmd.flatten!
    unseen = cmd[1...cmd.length]
    while not unseen.empty?
      data = $lackey.data
      unseen.delete_if { |u| data.has_key? u }
      sleep(0.2) unless unseen.empty?
    end
  end
end
WaitDataCommand.new

class WaitSignalCommand < Command
  def initialize
    super('wait_signal')
  end

  def handle(cmd)
    while $machine.get_signal.nil?
      sleep(0.2)
    end
  end
end
WaitSignalCommand.new

class SignalCommand < Command
  def initialize
    super('signal')
  end

  def handle(cmd)
    cmd.flatten!
    $machine.set_signal(cmd[1])
  end
end
SignalCommand.new

class DeleteCommand < Command
  def initialize
    super('delete')
    @action = PatternAction.new([])
  end
end
DeleteCommand.new

class RenameCommand < Command
  def initialize
    super('rename')
    @action = PatternAction.new([])
  end
end
RenameCommand.new

class PrintCommand < Command
  def initialize
    super('print')
  end

  def handle(cmd)
    return if $QUIET
    # Array containing arrays will be treated as multi-line output.
    cmd.shift
    multi = false
    cmd.each_index do |k|
      next unless cmd[k].is_a? Array
      multi = true
      cmd[k] = cmd[k].flatten.join(' ')
    end
    userout cmd.join(multi ? '\n' : ' ')
  end
end
PrintCommand.new

class ValueCommand < Command
  def handle_with_map(cmd, map)
    return if $QUIET
    cmd.flatten!
    cmd.shift
    out = []
    cmd.each { |id| out.push "#{id} : #{map.fetch(id, 'NOT FOUND')}" }
    userout out
  end
end

class SerialCommand < ValueCommand
  def initialize
    super('serial')
  end

  def handle(cmd)
    handle_with_map(cmd, $lackey.data)
  end
end
SerialCommand.new

class PIDCommand < ValueCommand
  def initialize
    super('pid')
  end

  def handle(cmd)
    handle_with_map(cmd, $lackey.process)
  end
end
PIDCommand.new

class ShellCommand < Command
  def initialize
    @rule =  { 'argv' => '*', 'script' => '*', 'stdout' => '?', 'stderr' => '?', '*' => '*' }
    super('script')
  end

  def handle(cmd)
    # Get interpreter and check that it exists.
    cmd.delete 'comment'
    argv = cmd.fetch('argv', [])
    cmd.delete 'argv'
    script = cmd['script'] # Pre-requisite for getting this far, exists.
    cmd.delete 'script'
    vout = cmd.fetch('stdout', nil)
    cmd.delete 'stdout'
    verr = cmd.fetch('stderr', nil)
    cmd.delete 'stderr'
    vin = cmd.fetch('stdin', nil)
    cmd.delete 'stdin'
    if cmd.length != 1
      $machine.set_error "Multiple interpreters: #{cmd.keys.sort.join(' ')}"
      return
    end
    interpreter = cmd.keys.first
    hashbangargs = cmd[cmd.keys.first]
    hashbangargs = hashbangargs.join(' ') if hashbangargs.is_a? Array
    unless File.exist?(interpreter) and File.executable?(interpreter)
      $machine.set_error "Not found or not an executable: #{interpreter}"
      return
    end
    # Write script into a temporary file.
    temp = Tempfile.new('fsm', Dir.tmpdir)
    begin
      temp.puts "#!#{interpreter} #{hashbangargs}"
      temp.puts script
      temp.chmod(0700)
      temp.close
      argv.prepend temp.path
    rescue StandardError => e
      $machine.set_error("Shell script prepare exception:\n#{e.to_s}")
      temp.close!
      return
    end
    wait = nil
    stdin = nil
    rd_out = nil
    rd_err = nil
    begin
      # Run script with arguments.
      stdin, stdout, stderr, wait = Open3.popen3(*argv)
      rd_out = vout.nil? ? DiscardReader.new(stdout) : StoringReader.new(stdout)
      rd_err = verr.nil? ? DiscardReader.new(stderr) : StoringReader.new(stderr)
      stdin.puts(vin) unless vin.nil?
      stdin.close
      wait.join
      $machine.variables[vout] = rd_out.readlines.join('\n') unless vout.nil?
      $machine.variables[verr] = rd_err.readlines.join('\n') unless verr.nil?
      exitcode = wait.value.exitstatus
      wait = nil
      $machine.set_error("Shell exit: #{exitcode}") if exitcode != 0
    rescue StandardError => e
      $machine.set_error("Shell run exception:\n#{e.to_s}")
    ensure
      stdin.close unless stdin.nil?
      rd_out.close unless rd_out.nil?
      rd_err.close unless rd_err.nil?
      wait.join unless wait.nil?
      temp.close!
    end
  end
end
ShellCommand.new

class RubyCommand < Command
  def initialize
    super('ruby')
  end

  def handle(cmd)
    # Access to variables via @variables in binding.
    script = cmd['ruby']
    script = script.join('\n') if script.is_a? Array
    begin
      eval(script, $machine.get_binding)
    rescue StandardError => e
      $machine.set_error "Eval failed: #{e.to_s}"
    end
  end
end
RubyCommand.new

# Load and parse all state files here.

$overwrites = []

def add_states(states, new_states)
  new_states.each_pair do |name, state|
    if states.has_key? name
      $overwrites.push({ :state => name }.merge(state[:load]))
    end
    states[name] = state
  end
end

$built_ins = { '__setup' => %q(
---
- __terminate_all:
  - close
  - wait_process terminate_delay
  - terminate
  comment: "Default termination, close feeds, terminate all after 5 seconds."
- __setup:
  - set pipes in JSON stdin out JSON stdout
  - set pipes_stderr in JSON stdin out JSON stdout out bytes stderr
  - set notify_all notify data notify process
  - [ set, terminate_delay, 5 ]
  global_signal2state:
    error: __terminate_all
  comment: |
    First state to run. Default variable set-up. Program will add first state
    in the first item of the first file with null key unless you set it when
    replacing this. Several states in the first item results in random pick.
) }

$first_state = nil

def load_statefile(filename, current_directory, parent_includes = [])
  if $built_ins.has_key? filename
    fullname = filename
    contents = YAML.load($built_ins[filename])
    directory = '(built-in)' # Built-in can include only another built-in.
  else
    begin
      fullname = File.realpath(filename, current_directory)
      contents = YAML.load(File.read(fullname))
      directory = File.dirname(fullname)
    rescue Errno::ENOENT => e
      userout e.to_s
      userout "Could not find #{filename} from #{current_directory}"
      return nil
    rescue StandardError => e
      userout e.to_s
      userout "Failed to read #{filename} from #{current_directory}"
      return nil
    end
  end
  if parent_includes.include? fullname
    userout "Include loop: #{filename} from #{current_directory}"
    return nil
  end
  unless contents.is_a? Array
    userout "Not a top level array: #{filename} from #{current_directory}"
    return nil
  end
  states = { }
  contents.each_index do |index|
    item = contents[index]
    common = { :load => { :source => fullname, :index => index } }
    begin
      item.delete 'comment'
      [ 'global_signal2state', 'signal2state', 'label2signal' ].each do |shared|
        next unless item.has_key? shared
        common[shared] = item[shared]
        item.delete shared
      end
    rescue NoMethodError
      userout "Item is not a mapping: #{fullname} : #{index}"
      return nil
    end
    include_name = item.fetch('include', nil)
    if include_name.nil?
      # Separate each state while keeping common parts.
      item.each_pair do |state, commands|
        if $first_state.nil?
          $first_state = state
          if item.length != 1
            userout "First state mapping with multiple states is ambiguous: #{fullname} : #{index}"
            return nil
          end
        end
        commands.each_index do |k|
          commands[k] = commands[k].split(' ') if commands[k].is_a? String
        end
        separated = common.clone
        separated[:commands] = commands
        add_states(states, { state => separated })
      end
    else
      parent_includes.push fullname
      included = load_statefile(include_name, directory, parent_includes)
      parent_includes.pop
      if included.nil?
        userout " .. #{fullname} : #{index}"
        return nil
      end
      add_states(states, included)
    end
  end
  return states
end

states = load_statefile('__setup', $root_dir)
$first_state = nil
ARGV.each do |filename|
  new_states = load_statefile(filename, $root_dir)
  exit(2) if new_states.nil?
  add_states(states, new_states)
end

if not $OVERWRITE_ACTION.nil? and not $overwrites.empty?
  $overwrites.each do |ow|
    userout "#{ow[:state]} replaced by #{ow[:source]} : #{ow[:index]}"
  end
  exit(4) if $OVERWRITE_ACTION == :error
end

unless states['__setup'].has_key? 'signal2state'
  states['__setup']['signal2state'] = { }
end
unless states['__setup']['signal2state'].has_key? nil
  states['__setup']['signal2state'][nil] = $first_state
end


def label_signal_check(category, action, message, vars)
  case category
  when 'internal'
    case action
    when 'stored'
      if $machine.label2signal.has_key? vars.first
        $machine.set_signal $machine.label2signal[vars.first]
      end
    when 'data_error'
      $machine.set_error(message.to_s)
    end
  when 'internal_error'
    $machine.set_error(message.to_s)
  end
end
sig_check = Proc.new { |ct, act, msg, vs| label_signal_check(ct, act, msg, vs) }

if $LACKEY.nil? and $MEMORY.nil? and $DIRECTORY.nil?
  # Running under datalackey.
  unless $PERMISSIONS.nil?
    userout "Cannot give --permissions/-p unless running datalackey."
    exit 1
  end
  userout "Running under datalackey."
  $lackey_proc = DatalackeyParentProcess.new($CMDOUT, STDIN)
  $lackey_stderr = DiscardReader.new($lackey_proc.stderr)
  $lackey = DatalackeyIO.new(
    $lackey_proc.stdin, $lackey_proc.stdout, nil, sig_check)
else
  begin
    $DIRECTORY, $PERMISSIONS, $MEMORY =
      DatalackeyProcess.verify_directory_permissions_memory(
        $DIRECTORY, $PERMISSIONS, $MEMORY)
    $lackey_proc = DatalackeyProcess.new(
      $LACKEY, $DIRECTORY, $PERMISSIONS, $MEMORY)
  rescue ArgumentError => e
    userout e.to_s
    exit 1
  end
  $lackey_stderr = StoringReader.new($lackey_proc.stderr)
  echo = $ECHO ? Proc.new { |json| userout json } : nil
  $lackey = DatalackeyIO.new($lackey_proc.stdin, $lackey_proc.stdout,
    $QUIET ? nil : Proc.new { |msgs| msgs.each { |m| userout m } }, sig_check,
    echo, echo)
end

$machine.run('__setup', states)
userout $lackey_stderr.readlines

$lackey_proc.finish
$lackey.close
$lackey_stderr.close
$lackey.finish
userout("datalackey exit: #{$lackey_proc.exit_code}") if $lackey_proc.exit_code != 0
exit $machine.variables.fetch('__exitcode', $machine.had_error ? 1 : 0)
